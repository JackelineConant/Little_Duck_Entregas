Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     empty -> <empty>
Rule 2     type -> INT
Rule 3     type -> FLOAT
Rule 4     type -> STRING
Rule 5     vars -> VAR var_ayuda
Rule 6     var_ayuda -> ID var_doble_ayuda : type ; var_ayuda_tail
Rule 7     var_ayuda_tail -> var_ayuda
Rule 8     var_ayuda_tail -> empty
Rule 9     var_doble_ayuda -> , ID var_doble_ayuda
Rule 10    var_doble_ayuda -> empty
Rule 11    exp -> exp + termino
Rule 12    exp -> exp - termino
Rule 13    exp -> termino
Rule 14    expression -> exp > exp
Rule 15    expression -> exp < exp
Rule 16    expression -> exp EQ exp
Rule 17    expression -> exp GE exp
Rule 18    expression -> exp LE exp
Rule 19    expression -> exp NE exp
Rule 20    expression -> exp
Rule 21    factor -> ( expression )
Rule 22    factor -> ID
Rule 23    factor -> cte
Rule 24    factor -> + ID
Rule 25    factor -> - ID
Rule 26    factor -> + cte
Rule 27    factor -> - cte
Rule 28    print -> PRINT ( expression print_ayuda ) ;
Rule 29    print -> PRINT ( CONST_STRING print_ayuda ) ;
Rule 30    print_ayuda -> , expression print_ayuda
Rule 31    print_ayuda -> , CONST_STRING print_ayuda
Rule 32    print_ayuda -> empty
Rule 33    termino -> termino * factor
Rule 34    termino -> termino / factor
Rule 35    termino -> factor
Rule 36    cycle -> DO marcar_cycle_inicio body marcar_cycle_final WHILE ( expression ) ;
Rule 37    marcar_cycle_inicio -> <empty>
Rule 38    marcar_cycle_final -> <empty>
Rule 39    condition -> IF ( expression ) marcar_if_inicio body ;
Rule 40    condition -> IF ( expression ) marcar_if_inicio body marcar_if_final ELSE marcar_else_inicio body marcar_else_final ;
Rule 41    marcar_if_inicio -> <empty>
Rule 42    marcar_if_final -> <empty>
Rule 43    marcar_else_inicio -> <empty>
Rule 44    marcar_else_final -> <empty>
Rule 45    assign -> ID = expression ;
Rule 46    f_call -> ID ( expression f_call_ayuda ) ;
Rule 47    f_call -> ID ( ) ;
Rule 48    f_call_ayuda -> , expression f_call_ayuda
Rule 49    f_call_ayuda -> empty
Rule 50    statements -> statements statement
Rule 51    statements -> statement
Rule 52    statement -> assign
Rule 53    statement -> condition
Rule 54    statement -> cycle
Rule 55    statement -> f_call
Rule 56    statement -> print
Rule 57    body -> { statements }
Rule 58    cte -> CONST_INT
Rule 59    cte -> CONST_FLOAT
Rule 60    cte -> CONST_STRING
Rule 61    func -> VOID ID ( ID : type funcs_ayuda ) func_start [ vars body ] ;
Rule 62    func -> VOID ID ( ) func_start [ vars body ] ;
Rule 63    func -> VOID ID ( ID : type funcs_ayuda ) func_start [ body ] ;
Rule 64    func -> VOID ID ( ) func_start [ body ] ;
Rule 65    func_start -> <empty>
Rule 66    funcs_list -> funcs_list func
Rule 67    funcs_list -> func
Rule 68    funcs_list -> empty
Rule 69    funcs_ayuda -> , ID : type funcs_ayuda
Rule 70    funcs_ayuda -> empty
Rule 71    program -> PROGRAM ID ; vars funcs_list MAIN inicio_main body END
Rule 72    inicio_main -> <empty>

Terminals, with rules where they appear

(                    : 21 28 29 36 39 40 46 47 61 62 63 64
)                    : 21 28 29 36 39 40 46 47 61 62 63 64
*                    : 33
+                    : 11 24 26
,                    : 9 30 31 48 69
-                    : 12 25 27
/                    : 34
:                    : 6 61 63 69
;                    : 6 28 29 36 39 40 45 46 47 61 62 63 64 71
<                    : 15
=                    : 45
>                    : 14
CONST_FLOAT          : 59
CONST_INT            : 58
CONST_STRING         : 29 31 60
DO                   : 36
ELSE                 : 40
END                  : 71
EQ                   : 16
FLOAT                : 3
GE                   : 17
ID                   : 6 9 22 24 25 45 46 47 61 61 62 63 63 64 69 71
IF                   : 39 40
INT                  : 2
LE                   : 18
MAIN                 : 71
NE                   : 19
PRINT                : 28 29
PROGRAM              : 71
STRING               : 4
VAR                  : 5
VOID                 : 61 62 63 64
WHILE                : 36
[                    : 61 62 63 64
]                    : 61 62 63 64
error                : 
{                    : 57
}                    : 57

Nonterminals, with rules where they appear

assign               : 52
body                 : 36 39 40 40 61 62 63 64 71
condition            : 53
cte                  : 23 26 27
cycle                : 54
empty                : 8 10 32 49 68 70
exp                  : 11 12 14 14 15 15 16 16 17 17 18 18 19 19 20
expression           : 21 28 30 36 39 40 45 46 48
f_call               : 55
f_call_ayuda         : 46 48
factor               : 33 34 35
func                 : 66 67
func_start           : 61 62 63 64
funcs_ayuda          : 61 63 69
funcs_list           : 66 71
inicio_main          : 71
marcar_cycle_final   : 36
marcar_cycle_inicio  : 36
marcar_else_final    : 40
marcar_else_inicio   : 40
marcar_if_final      : 40
marcar_if_inicio     : 39 40
print                : 56
print_ayuda          : 28 29 30 31
program              : 0
statement            : 50 51
statements           : 50 57
termino              : 11 12 13 33 34
type                 : 6 61 63 69
var_ayuda            : 5 7
var_ayuda_tail       : 6
var_doble_ayuda      : 6 9
vars                 : 61 62 71

Parsing method: LALR

state 0

    (0) S' -> . program
    (71) program -> . PROGRAM ID ; vars funcs_list MAIN inicio_main body END

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (71) program -> PROGRAM . ID ; vars funcs_list MAIN inicio_main body END

    ID              shift and go to state 3


state 3

    (71) program -> PROGRAM ID . ; vars funcs_list MAIN inicio_main body END

    ;               shift and go to state 4


state 4

    (71) program -> PROGRAM ID ; . vars funcs_list MAIN inicio_main body END
    (5) vars -> . VAR var_ayuda

    VAR             shift and go to state 6

    vars                           shift and go to state 5

state 5

    (71) program -> PROGRAM ID ; vars . funcs_list MAIN inicio_main body END
    (66) funcs_list -> . funcs_list func
    (67) funcs_list -> . func
    (68) funcs_list -> . empty
    (61) func -> . VOID ID ( ID : type funcs_ayuda ) func_start [ vars body ] ;
    (62) func -> . VOID ID ( ) func_start [ vars body ] ;
    (63) func -> . VOID ID ( ID : type funcs_ayuda ) func_start [ body ] ;
    (64) func -> . VOID ID ( ) func_start [ body ] ;
    (1) empty -> .

  ! shift/reduce conflict for VOID resolved as shift
    VOID            shift and go to state 10
    MAIN            reduce using rule 1 (empty -> .)

  ! VOID            [ reduce using rule 1 (empty -> .) ]

    funcs_list                     shift and go to state 7
    func                           shift and go to state 8
    empty                          shift and go to state 9

state 6

    (5) vars -> VAR . var_ayuda
    (6) var_ayuda -> . ID var_doble_ayuda : type ; var_ayuda_tail

    ID              shift and go to state 12

    var_ayuda                      shift and go to state 11

state 7

    (71) program -> PROGRAM ID ; vars funcs_list . MAIN inicio_main body END
    (66) funcs_list -> funcs_list . func
    (61) func -> . VOID ID ( ID : type funcs_ayuda ) func_start [ vars body ] ;
    (62) func -> . VOID ID ( ) func_start [ vars body ] ;
    (63) func -> . VOID ID ( ID : type funcs_ayuda ) func_start [ body ] ;
    (64) func -> . VOID ID ( ) func_start [ body ] ;

    MAIN            shift and go to state 13
    VOID            shift and go to state 10

    func                           shift and go to state 14

state 8

    (67) funcs_list -> func .

    MAIN            reduce using rule 67 (funcs_list -> func .)
    VOID            reduce using rule 67 (funcs_list -> func .)


state 9

    (68) funcs_list -> empty .

    MAIN            reduce using rule 68 (funcs_list -> empty .)
    VOID            reduce using rule 68 (funcs_list -> empty .)


state 10

    (61) func -> VOID . ID ( ID : type funcs_ayuda ) func_start [ vars body ] ;
    (62) func -> VOID . ID ( ) func_start [ vars body ] ;
    (63) func -> VOID . ID ( ID : type funcs_ayuda ) func_start [ body ] ;
    (64) func -> VOID . ID ( ) func_start [ body ] ;

    ID              shift and go to state 15


state 11

    (5) vars -> VAR var_ayuda .

    VOID            reduce using rule 5 (vars -> VAR var_ayuda .)
    MAIN            reduce using rule 5 (vars -> VAR var_ayuda .)
    {               reduce using rule 5 (vars -> VAR var_ayuda .)


state 12

    (6) var_ayuda -> ID . var_doble_ayuda : type ; var_ayuda_tail
    (9) var_doble_ayuda -> . , ID var_doble_ayuda
    (10) var_doble_ayuda -> . empty
    (1) empty -> .

    ,               shift and go to state 17
    :               reduce using rule 1 (empty -> .)

    var_doble_ayuda                shift and go to state 16
    empty                          shift and go to state 18

state 13

    (71) program -> PROGRAM ID ; vars funcs_list MAIN . inicio_main body END
    (72) inicio_main -> .

    {               reduce using rule 72 (inicio_main -> .)

    inicio_main                    shift and go to state 19

state 14

    (66) funcs_list -> funcs_list func .

    MAIN            reduce using rule 66 (funcs_list -> funcs_list func .)
    VOID            reduce using rule 66 (funcs_list -> funcs_list func .)


state 15

    (61) func -> VOID ID . ( ID : type funcs_ayuda ) func_start [ vars body ] ;
    (62) func -> VOID ID . ( ) func_start [ vars body ] ;
    (63) func -> VOID ID . ( ID : type funcs_ayuda ) func_start [ body ] ;
    (64) func -> VOID ID . ( ) func_start [ body ] ;

    (               shift and go to state 20


state 16

    (6) var_ayuda -> ID var_doble_ayuda . : type ; var_ayuda_tail

    :               shift and go to state 21


state 17

    (9) var_doble_ayuda -> , . ID var_doble_ayuda

    ID              shift and go to state 22


state 18

    (10) var_doble_ayuda -> empty .

    :               reduce using rule 10 (var_doble_ayuda -> empty .)


state 19

    (71) program -> PROGRAM ID ; vars funcs_list MAIN inicio_main . body END
    (57) body -> . { statements }

    {               shift and go to state 24

    body                           shift and go to state 23

state 20

    (61) func -> VOID ID ( . ID : type funcs_ayuda ) func_start [ vars body ] ;
    (62) func -> VOID ID ( . ) func_start [ vars body ] ;
    (63) func -> VOID ID ( . ID : type funcs_ayuda ) func_start [ body ] ;
    (64) func -> VOID ID ( . ) func_start [ body ] ;

    ID              shift and go to state 25
    )               shift and go to state 26


state 21

    (6) var_ayuda -> ID var_doble_ayuda : . type ; var_ayuda_tail
    (2) type -> . INT
    (3) type -> . FLOAT
    (4) type -> . STRING

    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    STRING          shift and go to state 30

    type                           shift and go to state 27

state 22

    (9) var_doble_ayuda -> , ID . var_doble_ayuda
    (9) var_doble_ayuda -> . , ID var_doble_ayuda
    (10) var_doble_ayuda -> . empty
    (1) empty -> .

    ,               shift and go to state 17
    :               reduce using rule 1 (empty -> .)

    var_doble_ayuda                shift and go to state 31
    empty                          shift and go to state 18

state 23

    (71) program -> PROGRAM ID ; vars funcs_list MAIN inicio_main body . END

    END             shift and go to state 32


state 24

    (57) body -> { . statements }
    (50) statements -> . statements statement
    (51) statements -> . statement
    (52) statement -> . assign
    (53) statement -> . condition
    (54) statement -> . cycle
    (55) statement -> . f_call
    (56) statement -> . print
    (45) assign -> . ID = expression ;
    (39) condition -> . IF ( expression ) marcar_if_inicio body ;
    (40) condition -> . IF ( expression ) marcar_if_inicio body marcar_if_final ELSE marcar_else_inicio body marcar_else_final ;
    (36) cycle -> . DO marcar_cycle_inicio body marcar_cycle_final WHILE ( expression ) ;
    (46) f_call -> . ID ( expression f_call_ayuda ) ;
    (47) f_call -> . ID ( ) ;
    (28) print -> . PRINT ( expression print_ayuda ) ;
    (29) print -> . PRINT ( CONST_STRING print_ayuda ) ;

    ID              shift and go to state 40
    IF              shift and go to state 41
    DO              shift and go to state 42
    PRINT           shift and go to state 43

    statements                     shift and go to state 33
    statement                      shift and go to state 34
    assign                         shift and go to state 35
    condition                      shift and go to state 36
    cycle                          shift and go to state 37
    f_call                         shift and go to state 38
    print                          shift and go to state 39

state 25

    (61) func -> VOID ID ( ID . : type funcs_ayuda ) func_start [ vars body ] ;
    (63) func -> VOID ID ( ID . : type funcs_ayuda ) func_start [ body ] ;

    :               shift and go to state 44


state 26

    (62) func -> VOID ID ( ) . func_start [ vars body ] ;
    (64) func -> VOID ID ( ) . func_start [ body ] ;
    (65) func_start -> .

    [               reduce using rule 65 (func_start -> .)

    func_start                     shift and go to state 45

state 27

    (6) var_ayuda -> ID var_doble_ayuda : type . ; var_ayuda_tail

    ;               shift and go to state 46


state 28

    (2) type -> INT .

    ;               reduce using rule 2 (type -> INT .)
    ,               reduce using rule 2 (type -> INT .)
    )               reduce using rule 2 (type -> INT .)


state 29

    (3) type -> FLOAT .

    ;               reduce using rule 3 (type -> FLOAT .)
    ,               reduce using rule 3 (type -> FLOAT .)
    )               reduce using rule 3 (type -> FLOAT .)


state 30

    (4) type -> STRING .

    ;               reduce using rule 4 (type -> STRING .)
    ,               reduce using rule 4 (type -> STRING .)
    )               reduce using rule 4 (type -> STRING .)


state 31

    (9) var_doble_ayuda -> , ID var_doble_ayuda .

    :               reduce using rule 9 (var_doble_ayuda -> , ID var_doble_ayuda .)


state 32

    (71) program -> PROGRAM ID ; vars funcs_list MAIN inicio_main body END .

    $end            reduce using rule 71 (program -> PROGRAM ID ; vars funcs_list MAIN inicio_main body END .)


state 33

    (57) body -> { statements . }
    (50) statements -> statements . statement
    (52) statement -> . assign
    (53) statement -> . condition
    (54) statement -> . cycle
    (55) statement -> . f_call
    (56) statement -> . print
    (45) assign -> . ID = expression ;
    (39) condition -> . IF ( expression ) marcar_if_inicio body ;
    (40) condition -> . IF ( expression ) marcar_if_inicio body marcar_if_final ELSE marcar_else_inicio body marcar_else_final ;
    (36) cycle -> . DO marcar_cycle_inicio body marcar_cycle_final WHILE ( expression ) ;
    (46) f_call -> . ID ( expression f_call_ayuda ) ;
    (47) f_call -> . ID ( ) ;
    (28) print -> . PRINT ( expression print_ayuda ) ;
    (29) print -> . PRINT ( CONST_STRING print_ayuda ) ;

    }               shift and go to state 47
    ID              shift and go to state 40
    IF              shift and go to state 41
    DO              shift and go to state 42
    PRINT           shift and go to state 43

    statement                      shift and go to state 48
    assign                         shift and go to state 35
    condition                      shift and go to state 36
    cycle                          shift and go to state 37
    f_call                         shift and go to state 38
    print                          shift and go to state 39

state 34

    (51) statements -> statement .

    }               reduce using rule 51 (statements -> statement .)
    ID              reduce using rule 51 (statements -> statement .)
    IF              reduce using rule 51 (statements -> statement .)
    DO              reduce using rule 51 (statements -> statement .)
    PRINT           reduce using rule 51 (statements -> statement .)


state 35

    (52) statement -> assign .

    }               reduce using rule 52 (statement -> assign .)
    ID              reduce using rule 52 (statement -> assign .)
    IF              reduce using rule 52 (statement -> assign .)
    DO              reduce using rule 52 (statement -> assign .)
    PRINT           reduce using rule 52 (statement -> assign .)


state 36

    (53) statement -> condition .

    }               reduce using rule 53 (statement -> condition .)
    ID              reduce using rule 53 (statement -> condition .)
    IF              reduce using rule 53 (statement -> condition .)
    DO              reduce using rule 53 (statement -> condition .)
    PRINT           reduce using rule 53 (statement -> condition .)


state 37

    (54) statement -> cycle .

    }               reduce using rule 54 (statement -> cycle .)
    ID              reduce using rule 54 (statement -> cycle .)
    IF              reduce using rule 54 (statement -> cycle .)
    DO              reduce using rule 54 (statement -> cycle .)
    PRINT           reduce using rule 54 (statement -> cycle .)


state 38

    (55) statement -> f_call .

    }               reduce using rule 55 (statement -> f_call .)
    ID              reduce using rule 55 (statement -> f_call .)
    IF              reduce using rule 55 (statement -> f_call .)
    DO              reduce using rule 55 (statement -> f_call .)
    PRINT           reduce using rule 55 (statement -> f_call .)


state 39

    (56) statement -> print .

    }               reduce using rule 56 (statement -> print .)
    ID              reduce using rule 56 (statement -> print .)
    IF              reduce using rule 56 (statement -> print .)
    DO              reduce using rule 56 (statement -> print .)
    PRINT           reduce using rule 56 (statement -> print .)


state 40

    (45) assign -> ID . = expression ;
    (46) f_call -> ID . ( expression f_call_ayuda ) ;
    (47) f_call -> ID . ( ) ;

    =               shift and go to state 49
    (               shift and go to state 50


state 41

    (39) condition -> IF . ( expression ) marcar_if_inicio body ;
    (40) condition -> IF . ( expression ) marcar_if_inicio body marcar_if_final ELSE marcar_else_inicio body marcar_else_final ;

    (               shift and go to state 51


state 42

    (36) cycle -> DO . marcar_cycle_inicio body marcar_cycle_final WHILE ( expression ) ;
    (37) marcar_cycle_inicio -> .

    {               reduce using rule 37 (marcar_cycle_inicio -> .)

    marcar_cycle_inicio            shift and go to state 52

state 43

    (28) print -> PRINT . ( expression print_ayuda ) ;
    (29) print -> PRINT . ( CONST_STRING print_ayuda ) ;

    (               shift and go to state 53


state 44

    (61) func -> VOID ID ( ID : . type funcs_ayuda ) func_start [ vars body ] ;
    (63) func -> VOID ID ( ID : . type funcs_ayuda ) func_start [ body ] ;
    (2) type -> . INT
    (3) type -> . FLOAT
    (4) type -> . STRING

    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    STRING          shift and go to state 30

    type                           shift and go to state 54

state 45

    (62) func -> VOID ID ( ) func_start . [ vars body ] ;
    (64) func -> VOID ID ( ) func_start . [ body ] ;

    [               shift and go to state 55


state 46

    (6) var_ayuda -> ID var_doble_ayuda : type ; . var_ayuda_tail
    (7) var_ayuda_tail -> . var_ayuda
    (8) var_ayuda_tail -> . empty
    (6) var_ayuda -> . ID var_doble_ayuda : type ; var_ayuda_tail
    (1) empty -> .

    ID              shift and go to state 12
    VOID            reduce using rule 1 (empty -> .)
    MAIN            reduce using rule 1 (empty -> .)
    {               reduce using rule 1 (empty -> .)

    var_ayuda_tail                 shift and go to state 56
    var_ayuda                      shift and go to state 57
    empty                          shift and go to state 58

state 47

    (57) body -> { statements } .

    END             reduce using rule 57 (body -> { statements } .)
    WHILE           reduce using rule 57 (body -> { statements } .)
    ]               reduce using rule 57 (body -> { statements } .)
    ;               reduce using rule 57 (body -> { statements } .)
    ELSE            reduce using rule 57 (body -> { statements } .)


state 48

    (50) statements -> statements statement .

    }               reduce using rule 50 (statements -> statements statement .)
    ID              reduce using rule 50 (statements -> statements statement .)
    IF              reduce using rule 50 (statements -> statements statement .)
    DO              reduce using rule 50 (statements -> statements statement .)
    PRINT           reduce using rule 50 (statements -> statements statement .)


state 49

    (45) assign -> ID = . expression ;
    (14) expression -> . exp > exp
    (15) expression -> . exp < exp
    (16) expression -> . exp EQ exp
    (17) expression -> . exp GE exp
    (18) expression -> . exp LE exp
    (19) expression -> . exp NE exp
    (20) expression -> . exp
    (11) exp -> . exp + termino
    (12) exp -> . exp - termino
    (13) exp -> . termino
    (33) termino -> . termino * factor
    (34) termino -> . termino / factor
    (35) termino -> . factor
    (21) factor -> . ( expression )
    (22) factor -> . ID
    (23) factor -> . cte
    (24) factor -> . + ID
    (25) factor -> . - ID
    (26) factor -> . + cte
    (27) factor -> . - cte
    (58) cte -> . CONST_INT
    (59) cte -> . CONST_FLOAT
    (60) cte -> . CONST_STRING

    (               shift and go to state 66
    ID              shift and go to state 59
    +               shift and go to state 62
    -               shift and go to state 64
    CONST_INT       shift and go to state 68
    CONST_FLOAT     shift and go to state 69
    CONST_STRING    shift and go to state 70

    expression                     shift and go to state 60
    exp                            shift and go to state 61
    termino                        shift and go to state 63
    factor                         shift and go to state 65
    cte                            shift and go to state 67

state 50

    (46) f_call -> ID ( . expression f_call_ayuda ) ;
    (47) f_call -> ID ( . ) ;
    (14) expression -> . exp > exp
    (15) expression -> . exp < exp
    (16) expression -> . exp EQ exp
    (17) expression -> . exp GE exp
    (18) expression -> . exp LE exp
    (19) expression -> . exp NE exp
    (20) expression -> . exp
    (11) exp -> . exp + termino
    (12) exp -> . exp - termino
    (13) exp -> . termino
    (33) termino -> . termino * factor
    (34) termino -> . termino / factor
    (35) termino -> . factor
    (21) factor -> . ( expression )
    (22) factor -> . ID
    (23) factor -> . cte
    (24) factor -> . + ID
    (25) factor -> . - ID
    (26) factor -> . + cte
    (27) factor -> . - cte
    (58) cte -> . CONST_INT
    (59) cte -> . CONST_FLOAT
    (60) cte -> . CONST_STRING

    )               shift and go to state 72
    (               shift and go to state 66
    ID              shift and go to state 59
    +               shift and go to state 62
    -               shift and go to state 64
    CONST_INT       shift and go to state 68
    CONST_FLOAT     shift and go to state 69
    CONST_STRING    shift and go to state 70

    expression                     shift and go to state 71
    exp                            shift and go to state 61
    termino                        shift and go to state 63
    factor                         shift and go to state 65
    cte                            shift and go to state 67

state 51

    (39) condition -> IF ( . expression ) marcar_if_inicio body ;
    (40) condition -> IF ( . expression ) marcar_if_inicio body marcar_if_final ELSE marcar_else_inicio body marcar_else_final ;
    (14) expression -> . exp > exp
    (15) expression -> . exp < exp
    (16) expression -> . exp EQ exp
    (17) expression -> . exp GE exp
    (18) expression -> . exp LE exp
    (19) expression -> . exp NE exp
    (20) expression -> . exp
    (11) exp -> . exp + termino
    (12) exp -> . exp - termino
    (13) exp -> . termino
    (33) termino -> . termino * factor
    (34) termino -> . termino / factor
    (35) termino -> . factor
    (21) factor -> . ( expression )
    (22) factor -> . ID
    (23) factor -> . cte
    (24) factor -> . + ID
    (25) factor -> . - ID
    (26) factor -> . + cte
    (27) factor -> . - cte
    (58) cte -> . CONST_INT
    (59) cte -> . CONST_FLOAT
    (60) cte -> . CONST_STRING

    (               shift and go to state 66
    ID              shift and go to state 59
    +               shift and go to state 62
    -               shift and go to state 64
    CONST_INT       shift and go to state 68
    CONST_FLOAT     shift and go to state 69
    CONST_STRING    shift and go to state 70

    expression                     shift and go to state 73
    exp                            shift and go to state 61
    termino                        shift and go to state 63
    factor                         shift and go to state 65
    cte                            shift and go to state 67

state 52

    (36) cycle -> DO marcar_cycle_inicio . body marcar_cycle_final WHILE ( expression ) ;
    (57) body -> . { statements }

    {               shift and go to state 24

    body                           shift and go to state 74

state 53

    (28) print -> PRINT ( . expression print_ayuda ) ;
    (29) print -> PRINT ( . CONST_STRING print_ayuda ) ;
    (14) expression -> . exp > exp
    (15) expression -> . exp < exp
    (16) expression -> . exp EQ exp
    (17) expression -> . exp GE exp
    (18) expression -> . exp LE exp
    (19) expression -> . exp NE exp
    (20) expression -> . exp
    (11) exp -> . exp + termino
    (12) exp -> . exp - termino
    (13) exp -> . termino
    (33) termino -> . termino * factor
    (34) termino -> . termino / factor
    (35) termino -> . factor
    (21) factor -> . ( expression )
    (22) factor -> . ID
    (23) factor -> . cte
    (24) factor -> . + ID
    (25) factor -> . - ID
    (26) factor -> . + cte
    (27) factor -> . - cte
    (58) cte -> . CONST_INT
    (59) cte -> . CONST_FLOAT
    (60) cte -> . CONST_STRING

    CONST_STRING    shift and go to state 76
    (               shift and go to state 66
    ID              shift and go to state 59
    +               shift and go to state 62
    -               shift and go to state 64
    CONST_INT       shift and go to state 68
    CONST_FLOAT     shift and go to state 69

    expression                     shift and go to state 75
    exp                            shift and go to state 61
    termino                        shift and go to state 63
    factor                         shift and go to state 65
    cte                            shift and go to state 67

state 54

    (61) func -> VOID ID ( ID : type . funcs_ayuda ) func_start [ vars body ] ;
    (63) func -> VOID ID ( ID : type . funcs_ayuda ) func_start [ body ] ;
    (69) funcs_ayuda -> . , ID : type funcs_ayuda
    (70) funcs_ayuda -> . empty
    (1) empty -> .

    ,               shift and go to state 78
    )               reduce using rule 1 (empty -> .)

    funcs_ayuda                    shift and go to state 77
    empty                          shift and go to state 79

state 55

    (62) func -> VOID ID ( ) func_start [ . vars body ] ;
    (64) func -> VOID ID ( ) func_start [ . body ] ;
    (5) vars -> . VAR var_ayuda
    (57) body -> . { statements }

    VAR             shift and go to state 6
    {               shift and go to state 24

    vars                           shift and go to state 80
    body                           shift and go to state 81

state 56

    (6) var_ayuda -> ID var_doble_ayuda : type ; var_ayuda_tail .

    VOID            reduce using rule 6 (var_ayuda -> ID var_doble_ayuda : type ; var_ayuda_tail .)
    MAIN            reduce using rule 6 (var_ayuda -> ID var_doble_ayuda : type ; var_ayuda_tail .)
    {               reduce using rule 6 (var_ayuda -> ID var_doble_ayuda : type ; var_ayuda_tail .)


state 57

    (7) var_ayuda_tail -> var_ayuda .

    VOID            reduce using rule 7 (var_ayuda_tail -> var_ayuda .)
    MAIN            reduce using rule 7 (var_ayuda_tail -> var_ayuda .)
    {               reduce using rule 7 (var_ayuda_tail -> var_ayuda .)


state 58

    (8) var_ayuda_tail -> empty .

    VOID            reduce using rule 8 (var_ayuda_tail -> empty .)
    MAIN            reduce using rule 8 (var_ayuda_tail -> empty .)
    {               reduce using rule 8 (var_ayuda_tail -> empty .)


state 59

    (22) factor -> ID .

    *               reduce using rule 22 (factor -> ID .)
    /               reduce using rule 22 (factor -> ID .)
    >               reduce using rule 22 (factor -> ID .)
    <               reduce using rule 22 (factor -> ID .)
    EQ              reduce using rule 22 (factor -> ID .)
    GE              reduce using rule 22 (factor -> ID .)
    LE              reduce using rule 22 (factor -> ID .)
    NE              reduce using rule 22 (factor -> ID .)
    +               reduce using rule 22 (factor -> ID .)
    -               reduce using rule 22 (factor -> ID .)
    ;               reduce using rule 22 (factor -> ID .)
    ,               reduce using rule 22 (factor -> ID .)
    )               reduce using rule 22 (factor -> ID .)


state 60

    (45) assign -> ID = expression . ;

    ;               shift and go to state 82


state 61

    (14) expression -> exp . > exp
    (15) expression -> exp . < exp
    (16) expression -> exp . EQ exp
    (17) expression -> exp . GE exp
    (18) expression -> exp . LE exp
    (19) expression -> exp . NE exp
    (20) expression -> exp .
    (11) exp -> exp . + termino
    (12) exp -> exp . - termino

    >               shift and go to state 83
    <               shift and go to state 84
    EQ              shift and go to state 85
    GE              shift and go to state 86
    LE              shift and go to state 87
    NE              shift and go to state 88
    ;               reduce using rule 20 (expression -> exp .)
    ,               reduce using rule 20 (expression -> exp .)
    )               reduce using rule 20 (expression -> exp .)
    +               shift and go to state 89
    -               shift and go to state 90


state 62

    (24) factor -> + . ID
    (26) factor -> + . cte
    (58) cte -> . CONST_INT
    (59) cte -> . CONST_FLOAT
    (60) cte -> . CONST_STRING

    ID              shift and go to state 91
    CONST_INT       shift and go to state 68
    CONST_FLOAT     shift and go to state 69
    CONST_STRING    shift and go to state 70

    cte                            shift and go to state 92

state 63

    (13) exp -> termino .
    (33) termino -> termino . * factor
    (34) termino -> termino . / factor

    >               reduce using rule 13 (exp -> termino .)
    <               reduce using rule 13 (exp -> termino .)
    EQ              reduce using rule 13 (exp -> termino .)
    GE              reduce using rule 13 (exp -> termino .)
    LE              reduce using rule 13 (exp -> termino .)
    NE              reduce using rule 13 (exp -> termino .)
    +               reduce using rule 13 (exp -> termino .)
    -               reduce using rule 13 (exp -> termino .)
    ;               reduce using rule 13 (exp -> termino .)
    ,               reduce using rule 13 (exp -> termino .)
    )               reduce using rule 13 (exp -> termino .)
    *               shift and go to state 93
    /               shift and go to state 94


state 64

    (25) factor -> - . ID
    (27) factor -> - . cte
    (58) cte -> . CONST_INT
    (59) cte -> . CONST_FLOAT
    (60) cte -> . CONST_STRING

    ID              shift and go to state 95
    CONST_INT       shift and go to state 68
    CONST_FLOAT     shift and go to state 69
    CONST_STRING    shift and go to state 70

    cte                            shift and go to state 96

state 65

    (35) termino -> factor .

    *               reduce using rule 35 (termino -> factor .)
    /               reduce using rule 35 (termino -> factor .)
    >               reduce using rule 35 (termino -> factor .)
    <               reduce using rule 35 (termino -> factor .)
    EQ              reduce using rule 35 (termino -> factor .)
    GE              reduce using rule 35 (termino -> factor .)
    LE              reduce using rule 35 (termino -> factor .)
    NE              reduce using rule 35 (termino -> factor .)
    +               reduce using rule 35 (termino -> factor .)
    -               reduce using rule 35 (termino -> factor .)
    ;               reduce using rule 35 (termino -> factor .)
    ,               reduce using rule 35 (termino -> factor .)
    )               reduce using rule 35 (termino -> factor .)


state 66

    (21) factor -> ( . expression )
    (14) expression -> . exp > exp
    (15) expression -> . exp < exp
    (16) expression -> . exp EQ exp
    (17) expression -> . exp GE exp
    (18) expression -> . exp LE exp
    (19) expression -> . exp NE exp
    (20) expression -> . exp
    (11) exp -> . exp + termino
    (12) exp -> . exp - termino
    (13) exp -> . termino
    (33) termino -> . termino * factor
    (34) termino -> . termino / factor
    (35) termino -> . factor
    (21) factor -> . ( expression )
    (22) factor -> . ID
    (23) factor -> . cte
    (24) factor -> . + ID
    (25) factor -> . - ID
    (26) factor -> . + cte
    (27) factor -> . - cte
    (58) cte -> . CONST_INT
    (59) cte -> . CONST_FLOAT
    (60) cte -> . CONST_STRING

    (               shift and go to state 66
    ID              shift and go to state 59
    +               shift and go to state 62
    -               shift and go to state 64
    CONST_INT       shift and go to state 68
    CONST_FLOAT     shift and go to state 69
    CONST_STRING    shift and go to state 70

    expression                     shift and go to state 97
    exp                            shift and go to state 61
    termino                        shift and go to state 63
    factor                         shift and go to state 65
    cte                            shift and go to state 67

state 67

    (23) factor -> cte .

    *               reduce using rule 23 (factor -> cte .)
    /               reduce using rule 23 (factor -> cte .)
    >               reduce using rule 23 (factor -> cte .)
    <               reduce using rule 23 (factor -> cte .)
    EQ              reduce using rule 23 (factor -> cte .)
    GE              reduce using rule 23 (factor -> cte .)
    LE              reduce using rule 23 (factor -> cte .)
    NE              reduce using rule 23 (factor -> cte .)
    +               reduce using rule 23 (factor -> cte .)
    -               reduce using rule 23 (factor -> cte .)
    ;               reduce using rule 23 (factor -> cte .)
    ,               reduce using rule 23 (factor -> cte .)
    )               reduce using rule 23 (factor -> cte .)


state 68

    (58) cte -> CONST_INT .

    *               reduce using rule 58 (cte -> CONST_INT .)
    /               reduce using rule 58 (cte -> CONST_INT .)
    >               reduce using rule 58 (cte -> CONST_INT .)
    <               reduce using rule 58 (cte -> CONST_INT .)
    EQ              reduce using rule 58 (cte -> CONST_INT .)
    GE              reduce using rule 58 (cte -> CONST_INT .)
    LE              reduce using rule 58 (cte -> CONST_INT .)
    NE              reduce using rule 58 (cte -> CONST_INT .)
    +               reduce using rule 58 (cte -> CONST_INT .)
    -               reduce using rule 58 (cte -> CONST_INT .)
    ;               reduce using rule 58 (cte -> CONST_INT .)
    ,               reduce using rule 58 (cte -> CONST_INT .)
    )               reduce using rule 58 (cte -> CONST_INT .)


state 69

    (59) cte -> CONST_FLOAT .

    *               reduce using rule 59 (cte -> CONST_FLOAT .)
    /               reduce using rule 59 (cte -> CONST_FLOAT .)
    >               reduce using rule 59 (cte -> CONST_FLOAT .)
    <               reduce using rule 59 (cte -> CONST_FLOAT .)
    EQ              reduce using rule 59 (cte -> CONST_FLOAT .)
    GE              reduce using rule 59 (cte -> CONST_FLOAT .)
    LE              reduce using rule 59 (cte -> CONST_FLOAT .)
    NE              reduce using rule 59 (cte -> CONST_FLOAT .)
    +               reduce using rule 59 (cte -> CONST_FLOAT .)
    -               reduce using rule 59 (cte -> CONST_FLOAT .)
    ;               reduce using rule 59 (cte -> CONST_FLOAT .)
    ,               reduce using rule 59 (cte -> CONST_FLOAT .)
    )               reduce using rule 59 (cte -> CONST_FLOAT .)


state 70

    (60) cte -> CONST_STRING .

    *               reduce using rule 60 (cte -> CONST_STRING .)
    /               reduce using rule 60 (cte -> CONST_STRING .)
    >               reduce using rule 60 (cte -> CONST_STRING .)
    <               reduce using rule 60 (cte -> CONST_STRING .)
    EQ              reduce using rule 60 (cte -> CONST_STRING .)
    GE              reduce using rule 60 (cte -> CONST_STRING .)
    LE              reduce using rule 60 (cte -> CONST_STRING .)
    NE              reduce using rule 60 (cte -> CONST_STRING .)
    +               reduce using rule 60 (cte -> CONST_STRING .)
    -               reduce using rule 60 (cte -> CONST_STRING .)
    ;               reduce using rule 60 (cte -> CONST_STRING .)
    ,               reduce using rule 60 (cte -> CONST_STRING .)
    )               reduce using rule 60 (cte -> CONST_STRING .)


state 71

    (46) f_call -> ID ( expression . f_call_ayuda ) ;
    (48) f_call_ayuda -> . , expression f_call_ayuda
    (49) f_call_ayuda -> . empty
    (1) empty -> .

    ,               shift and go to state 99
    )               reduce using rule 1 (empty -> .)

    f_call_ayuda                   shift and go to state 98
    empty                          shift and go to state 100

state 72

    (47) f_call -> ID ( ) . ;

    ;               shift and go to state 101


state 73

    (39) condition -> IF ( expression . ) marcar_if_inicio body ;
    (40) condition -> IF ( expression . ) marcar_if_inicio body marcar_if_final ELSE marcar_else_inicio body marcar_else_final ;

    )               shift and go to state 102


state 74

    (36) cycle -> DO marcar_cycle_inicio body . marcar_cycle_final WHILE ( expression ) ;
    (38) marcar_cycle_final -> .

    WHILE           reduce using rule 38 (marcar_cycle_final -> .)

    marcar_cycle_final             shift and go to state 103

state 75

    (28) print -> PRINT ( expression . print_ayuda ) ;
    (30) print_ayuda -> . , expression print_ayuda
    (31) print_ayuda -> . , CONST_STRING print_ayuda
    (32) print_ayuda -> . empty
    (1) empty -> .

    ,               shift and go to state 105
    )               reduce using rule 1 (empty -> .)

    print_ayuda                    shift and go to state 104
    empty                          shift and go to state 106

state 76

    (29) print -> PRINT ( CONST_STRING . print_ayuda ) ;
    (60) cte -> CONST_STRING .
    (30) print_ayuda -> . , expression print_ayuda
    (31) print_ayuda -> . , CONST_STRING print_ayuda
    (32) print_ayuda -> . empty
    (1) empty -> .

  ! shift/reduce conflict for , resolved as shift
  ! reduce/reduce conflict for ) resolved using rule 1 (empty -> .)
    *               reduce using rule 60 (cte -> CONST_STRING .)
    /               reduce using rule 60 (cte -> CONST_STRING .)
    >               reduce using rule 60 (cte -> CONST_STRING .)
    <               reduce using rule 60 (cte -> CONST_STRING .)
    EQ              reduce using rule 60 (cte -> CONST_STRING .)
    GE              reduce using rule 60 (cte -> CONST_STRING .)
    LE              reduce using rule 60 (cte -> CONST_STRING .)
    NE              reduce using rule 60 (cte -> CONST_STRING .)
    +               reduce using rule 60 (cte -> CONST_STRING .)
    -               reduce using rule 60 (cte -> CONST_STRING .)
    ,               shift and go to state 105
    )               reduce using rule 1 (empty -> .)

  ! ,               [ reduce using rule 60 (cte -> CONST_STRING .) ]
  ! )               [ reduce using rule 60 (cte -> CONST_STRING .) ]

    print_ayuda                    shift and go to state 107
    empty                          shift and go to state 106

state 77

    (61) func -> VOID ID ( ID : type funcs_ayuda . ) func_start [ vars body ] ;
    (63) func -> VOID ID ( ID : type funcs_ayuda . ) func_start [ body ] ;

    )               shift and go to state 108


state 78

    (69) funcs_ayuda -> , . ID : type funcs_ayuda

    ID              shift and go to state 109


state 79

    (70) funcs_ayuda -> empty .

    )               reduce using rule 70 (funcs_ayuda -> empty .)


state 80

    (62) func -> VOID ID ( ) func_start [ vars . body ] ;
    (57) body -> . { statements }

    {               shift and go to state 24

    body                           shift and go to state 110

state 81

    (64) func -> VOID ID ( ) func_start [ body . ] ;

    ]               shift and go to state 111


state 82

    (45) assign -> ID = expression ; .

    }               reduce using rule 45 (assign -> ID = expression ; .)
    ID              reduce using rule 45 (assign -> ID = expression ; .)
    IF              reduce using rule 45 (assign -> ID = expression ; .)
    DO              reduce using rule 45 (assign -> ID = expression ; .)
    PRINT           reduce using rule 45 (assign -> ID = expression ; .)


state 83

    (14) expression -> exp > . exp
    (11) exp -> . exp + termino
    (12) exp -> . exp - termino
    (13) exp -> . termino
    (33) termino -> . termino * factor
    (34) termino -> . termino / factor
    (35) termino -> . factor
    (21) factor -> . ( expression )
    (22) factor -> . ID
    (23) factor -> . cte
    (24) factor -> . + ID
    (25) factor -> . - ID
    (26) factor -> . + cte
    (27) factor -> . - cte
    (58) cte -> . CONST_INT
    (59) cte -> . CONST_FLOAT
    (60) cte -> . CONST_STRING

    (               shift and go to state 66
    ID              shift and go to state 59
    +               shift and go to state 62
    -               shift and go to state 64
    CONST_INT       shift and go to state 68
    CONST_FLOAT     shift and go to state 69
    CONST_STRING    shift and go to state 70

    exp                            shift and go to state 112
    termino                        shift and go to state 63
    factor                         shift and go to state 65
    cte                            shift and go to state 67

state 84

    (15) expression -> exp < . exp
    (11) exp -> . exp + termino
    (12) exp -> . exp - termino
    (13) exp -> . termino
    (33) termino -> . termino * factor
    (34) termino -> . termino / factor
    (35) termino -> . factor
    (21) factor -> . ( expression )
    (22) factor -> . ID
    (23) factor -> . cte
    (24) factor -> . + ID
    (25) factor -> . - ID
    (26) factor -> . + cte
    (27) factor -> . - cte
    (58) cte -> . CONST_INT
    (59) cte -> . CONST_FLOAT
    (60) cte -> . CONST_STRING

    (               shift and go to state 66
    ID              shift and go to state 59
    +               shift and go to state 62
    -               shift and go to state 64
    CONST_INT       shift and go to state 68
    CONST_FLOAT     shift and go to state 69
    CONST_STRING    shift and go to state 70

    exp                            shift and go to state 113
    termino                        shift and go to state 63
    factor                         shift and go to state 65
    cte                            shift and go to state 67

state 85

    (16) expression -> exp EQ . exp
    (11) exp -> . exp + termino
    (12) exp -> . exp - termino
    (13) exp -> . termino
    (33) termino -> . termino * factor
    (34) termino -> . termino / factor
    (35) termino -> . factor
    (21) factor -> . ( expression )
    (22) factor -> . ID
    (23) factor -> . cte
    (24) factor -> . + ID
    (25) factor -> . - ID
    (26) factor -> . + cte
    (27) factor -> . - cte
    (58) cte -> . CONST_INT
    (59) cte -> . CONST_FLOAT
    (60) cte -> . CONST_STRING

    (               shift and go to state 66
    ID              shift and go to state 59
    +               shift and go to state 62
    -               shift and go to state 64
    CONST_INT       shift and go to state 68
    CONST_FLOAT     shift and go to state 69
    CONST_STRING    shift and go to state 70

    exp                            shift and go to state 114
    termino                        shift and go to state 63
    factor                         shift and go to state 65
    cte                            shift and go to state 67

state 86

    (17) expression -> exp GE . exp
    (11) exp -> . exp + termino
    (12) exp -> . exp - termino
    (13) exp -> . termino
    (33) termino -> . termino * factor
    (34) termino -> . termino / factor
    (35) termino -> . factor
    (21) factor -> . ( expression )
    (22) factor -> . ID
    (23) factor -> . cte
    (24) factor -> . + ID
    (25) factor -> . - ID
    (26) factor -> . + cte
    (27) factor -> . - cte
    (58) cte -> . CONST_INT
    (59) cte -> . CONST_FLOAT
    (60) cte -> . CONST_STRING

    (               shift and go to state 66
    ID              shift and go to state 59
    +               shift and go to state 62
    -               shift and go to state 64
    CONST_INT       shift and go to state 68
    CONST_FLOAT     shift and go to state 69
    CONST_STRING    shift and go to state 70

    exp                            shift and go to state 115
    termino                        shift and go to state 63
    factor                         shift and go to state 65
    cte                            shift and go to state 67

state 87

    (18) expression -> exp LE . exp
    (11) exp -> . exp + termino
    (12) exp -> . exp - termino
    (13) exp -> . termino
    (33) termino -> . termino * factor
    (34) termino -> . termino / factor
    (35) termino -> . factor
    (21) factor -> . ( expression )
    (22) factor -> . ID
    (23) factor -> . cte
    (24) factor -> . + ID
    (25) factor -> . - ID
    (26) factor -> . + cte
    (27) factor -> . - cte
    (58) cte -> . CONST_INT
    (59) cte -> . CONST_FLOAT
    (60) cte -> . CONST_STRING

    (               shift and go to state 66
    ID              shift and go to state 59
    +               shift and go to state 62
    -               shift and go to state 64
    CONST_INT       shift and go to state 68
    CONST_FLOAT     shift and go to state 69
    CONST_STRING    shift and go to state 70

    exp                            shift and go to state 116
    termino                        shift and go to state 63
    factor                         shift and go to state 65
    cte                            shift and go to state 67

state 88

    (19) expression -> exp NE . exp
    (11) exp -> . exp + termino
    (12) exp -> . exp - termino
    (13) exp -> . termino
    (33) termino -> . termino * factor
    (34) termino -> . termino / factor
    (35) termino -> . factor
    (21) factor -> . ( expression )
    (22) factor -> . ID
    (23) factor -> . cte
    (24) factor -> . + ID
    (25) factor -> . - ID
    (26) factor -> . + cte
    (27) factor -> . - cte
    (58) cte -> . CONST_INT
    (59) cte -> . CONST_FLOAT
    (60) cte -> . CONST_STRING

    (               shift and go to state 66
    ID              shift and go to state 59
    +               shift and go to state 62
    -               shift and go to state 64
    CONST_INT       shift and go to state 68
    CONST_FLOAT     shift and go to state 69
    CONST_STRING    shift and go to state 70

    exp                            shift and go to state 117
    termino                        shift and go to state 63
    factor                         shift and go to state 65
    cte                            shift and go to state 67

state 89

    (11) exp -> exp + . termino
    (33) termino -> . termino * factor
    (34) termino -> . termino / factor
    (35) termino -> . factor
    (21) factor -> . ( expression )
    (22) factor -> . ID
    (23) factor -> . cte
    (24) factor -> . + ID
    (25) factor -> . - ID
    (26) factor -> . + cte
    (27) factor -> . - cte
    (58) cte -> . CONST_INT
    (59) cte -> . CONST_FLOAT
    (60) cte -> . CONST_STRING

    (               shift and go to state 66
    ID              shift and go to state 59
    +               shift and go to state 62
    -               shift and go to state 64
    CONST_INT       shift and go to state 68
    CONST_FLOAT     shift and go to state 69
    CONST_STRING    shift and go to state 70

    termino                        shift and go to state 118
    factor                         shift and go to state 65
    cte                            shift and go to state 67

state 90

    (12) exp -> exp - . termino
    (33) termino -> . termino * factor
    (34) termino -> . termino / factor
    (35) termino -> . factor
    (21) factor -> . ( expression )
    (22) factor -> . ID
    (23) factor -> . cte
    (24) factor -> . + ID
    (25) factor -> . - ID
    (26) factor -> . + cte
    (27) factor -> . - cte
    (58) cte -> . CONST_INT
    (59) cte -> . CONST_FLOAT
    (60) cte -> . CONST_STRING

    (               shift and go to state 66
    ID              shift and go to state 59
    +               shift and go to state 62
    -               shift and go to state 64
    CONST_INT       shift and go to state 68
    CONST_FLOAT     shift and go to state 69
    CONST_STRING    shift and go to state 70

    termino                        shift and go to state 119
    factor                         shift and go to state 65
    cte                            shift and go to state 67

state 91

    (24) factor -> + ID .

    *               reduce using rule 24 (factor -> + ID .)
    /               reduce using rule 24 (factor -> + ID .)
    >               reduce using rule 24 (factor -> + ID .)
    <               reduce using rule 24 (factor -> + ID .)
    EQ              reduce using rule 24 (factor -> + ID .)
    GE              reduce using rule 24 (factor -> + ID .)
    LE              reduce using rule 24 (factor -> + ID .)
    NE              reduce using rule 24 (factor -> + ID .)
    +               reduce using rule 24 (factor -> + ID .)
    -               reduce using rule 24 (factor -> + ID .)
    ;               reduce using rule 24 (factor -> + ID .)
    ,               reduce using rule 24 (factor -> + ID .)
    )               reduce using rule 24 (factor -> + ID .)


state 92

    (26) factor -> + cte .

    *               reduce using rule 26 (factor -> + cte .)
    /               reduce using rule 26 (factor -> + cte .)
    >               reduce using rule 26 (factor -> + cte .)
    <               reduce using rule 26 (factor -> + cte .)
    EQ              reduce using rule 26 (factor -> + cte .)
    GE              reduce using rule 26 (factor -> + cte .)
    LE              reduce using rule 26 (factor -> + cte .)
    NE              reduce using rule 26 (factor -> + cte .)
    +               reduce using rule 26 (factor -> + cte .)
    -               reduce using rule 26 (factor -> + cte .)
    ;               reduce using rule 26 (factor -> + cte .)
    ,               reduce using rule 26 (factor -> + cte .)
    )               reduce using rule 26 (factor -> + cte .)


state 93

    (33) termino -> termino * . factor
    (21) factor -> . ( expression )
    (22) factor -> . ID
    (23) factor -> . cte
    (24) factor -> . + ID
    (25) factor -> . - ID
    (26) factor -> . + cte
    (27) factor -> . - cte
    (58) cte -> . CONST_INT
    (59) cte -> . CONST_FLOAT
    (60) cte -> . CONST_STRING

    (               shift and go to state 66
    ID              shift and go to state 59
    +               shift and go to state 62
    -               shift and go to state 64
    CONST_INT       shift and go to state 68
    CONST_FLOAT     shift and go to state 69
    CONST_STRING    shift and go to state 70

    factor                         shift and go to state 120
    cte                            shift and go to state 67

state 94

    (34) termino -> termino / . factor
    (21) factor -> . ( expression )
    (22) factor -> . ID
    (23) factor -> . cte
    (24) factor -> . + ID
    (25) factor -> . - ID
    (26) factor -> . + cte
    (27) factor -> . - cte
    (58) cte -> . CONST_INT
    (59) cte -> . CONST_FLOAT
    (60) cte -> . CONST_STRING

    (               shift and go to state 66
    ID              shift and go to state 59
    +               shift and go to state 62
    -               shift and go to state 64
    CONST_INT       shift and go to state 68
    CONST_FLOAT     shift and go to state 69
    CONST_STRING    shift and go to state 70

    factor                         shift and go to state 121
    cte                            shift and go to state 67

state 95

    (25) factor -> - ID .

    *               reduce using rule 25 (factor -> - ID .)
    /               reduce using rule 25 (factor -> - ID .)
    >               reduce using rule 25 (factor -> - ID .)
    <               reduce using rule 25 (factor -> - ID .)
    EQ              reduce using rule 25 (factor -> - ID .)
    GE              reduce using rule 25 (factor -> - ID .)
    LE              reduce using rule 25 (factor -> - ID .)
    NE              reduce using rule 25 (factor -> - ID .)
    +               reduce using rule 25 (factor -> - ID .)
    -               reduce using rule 25 (factor -> - ID .)
    ;               reduce using rule 25 (factor -> - ID .)
    ,               reduce using rule 25 (factor -> - ID .)
    )               reduce using rule 25 (factor -> - ID .)


state 96

    (27) factor -> - cte .

    *               reduce using rule 27 (factor -> - cte .)
    /               reduce using rule 27 (factor -> - cte .)
    >               reduce using rule 27 (factor -> - cte .)
    <               reduce using rule 27 (factor -> - cte .)
    EQ              reduce using rule 27 (factor -> - cte .)
    GE              reduce using rule 27 (factor -> - cte .)
    LE              reduce using rule 27 (factor -> - cte .)
    NE              reduce using rule 27 (factor -> - cte .)
    +               reduce using rule 27 (factor -> - cte .)
    -               reduce using rule 27 (factor -> - cte .)
    ;               reduce using rule 27 (factor -> - cte .)
    ,               reduce using rule 27 (factor -> - cte .)
    )               reduce using rule 27 (factor -> - cte .)


state 97

    (21) factor -> ( expression . )

    )               shift and go to state 122


state 98

    (46) f_call -> ID ( expression f_call_ayuda . ) ;

    )               shift and go to state 123


state 99

    (48) f_call_ayuda -> , . expression f_call_ayuda
    (14) expression -> . exp > exp
    (15) expression -> . exp < exp
    (16) expression -> . exp EQ exp
    (17) expression -> . exp GE exp
    (18) expression -> . exp LE exp
    (19) expression -> . exp NE exp
    (20) expression -> . exp
    (11) exp -> . exp + termino
    (12) exp -> . exp - termino
    (13) exp -> . termino
    (33) termino -> . termino * factor
    (34) termino -> . termino / factor
    (35) termino -> . factor
    (21) factor -> . ( expression )
    (22) factor -> . ID
    (23) factor -> . cte
    (24) factor -> . + ID
    (25) factor -> . - ID
    (26) factor -> . + cte
    (27) factor -> . - cte
    (58) cte -> . CONST_INT
    (59) cte -> . CONST_FLOAT
    (60) cte -> . CONST_STRING

    (               shift and go to state 66
    ID              shift and go to state 59
    +               shift and go to state 62
    -               shift and go to state 64
    CONST_INT       shift and go to state 68
    CONST_FLOAT     shift and go to state 69
    CONST_STRING    shift and go to state 70

    expression                     shift and go to state 124
    exp                            shift and go to state 61
    termino                        shift and go to state 63
    factor                         shift and go to state 65
    cte                            shift and go to state 67

state 100

    (49) f_call_ayuda -> empty .

    )               reduce using rule 49 (f_call_ayuda -> empty .)


state 101

    (47) f_call -> ID ( ) ; .

    }               reduce using rule 47 (f_call -> ID ( ) ; .)
    ID              reduce using rule 47 (f_call -> ID ( ) ; .)
    IF              reduce using rule 47 (f_call -> ID ( ) ; .)
    DO              reduce using rule 47 (f_call -> ID ( ) ; .)
    PRINT           reduce using rule 47 (f_call -> ID ( ) ; .)


state 102

    (39) condition -> IF ( expression ) . marcar_if_inicio body ;
    (40) condition -> IF ( expression ) . marcar_if_inicio body marcar_if_final ELSE marcar_else_inicio body marcar_else_final ;
    (41) marcar_if_inicio -> .

    {               reduce using rule 41 (marcar_if_inicio -> .)

    marcar_if_inicio               shift and go to state 125

state 103

    (36) cycle -> DO marcar_cycle_inicio body marcar_cycle_final . WHILE ( expression ) ;

    WHILE           shift and go to state 126


state 104

    (28) print -> PRINT ( expression print_ayuda . ) ;

    )               shift and go to state 127


state 105

    (30) print_ayuda -> , . expression print_ayuda
    (31) print_ayuda -> , . CONST_STRING print_ayuda
    (14) expression -> . exp > exp
    (15) expression -> . exp < exp
    (16) expression -> . exp EQ exp
    (17) expression -> . exp GE exp
    (18) expression -> . exp LE exp
    (19) expression -> . exp NE exp
    (20) expression -> . exp
    (11) exp -> . exp + termino
    (12) exp -> . exp - termino
    (13) exp -> . termino
    (33) termino -> . termino * factor
    (34) termino -> . termino / factor
    (35) termino -> . factor
    (21) factor -> . ( expression )
    (22) factor -> . ID
    (23) factor -> . cte
    (24) factor -> . + ID
    (25) factor -> . - ID
    (26) factor -> . + cte
    (27) factor -> . - cte
    (58) cte -> . CONST_INT
    (59) cte -> . CONST_FLOAT
    (60) cte -> . CONST_STRING

    CONST_STRING    shift and go to state 129
    (               shift and go to state 66
    ID              shift and go to state 59
    +               shift and go to state 62
    -               shift and go to state 64
    CONST_INT       shift and go to state 68
    CONST_FLOAT     shift and go to state 69

    expression                     shift and go to state 128
    exp                            shift and go to state 61
    termino                        shift and go to state 63
    factor                         shift and go to state 65
    cte                            shift and go to state 67

state 106

    (32) print_ayuda -> empty .

    )               reduce using rule 32 (print_ayuda -> empty .)


state 107

    (29) print -> PRINT ( CONST_STRING print_ayuda . ) ;

    )               shift and go to state 130


state 108

    (61) func -> VOID ID ( ID : type funcs_ayuda ) . func_start [ vars body ] ;
    (63) func -> VOID ID ( ID : type funcs_ayuda ) . func_start [ body ] ;
    (65) func_start -> .

    [               reduce using rule 65 (func_start -> .)

    func_start                     shift and go to state 131

state 109

    (69) funcs_ayuda -> , ID . : type funcs_ayuda

    :               shift and go to state 132


state 110

    (62) func -> VOID ID ( ) func_start [ vars body . ] ;

    ]               shift and go to state 133


state 111

    (64) func -> VOID ID ( ) func_start [ body ] . ;

    ;               shift and go to state 134


state 112

    (14) expression -> exp > exp .
    (11) exp -> exp . + termino
    (12) exp -> exp . - termino

    ;               reduce using rule 14 (expression -> exp > exp .)
    ,               reduce using rule 14 (expression -> exp > exp .)
    )               reduce using rule 14 (expression -> exp > exp .)
    +               shift and go to state 89
    -               shift and go to state 90


state 113

    (15) expression -> exp < exp .
    (11) exp -> exp . + termino
    (12) exp -> exp . - termino

    ;               reduce using rule 15 (expression -> exp < exp .)
    ,               reduce using rule 15 (expression -> exp < exp .)
    )               reduce using rule 15 (expression -> exp < exp .)
    +               shift and go to state 89
    -               shift and go to state 90


state 114

    (16) expression -> exp EQ exp .
    (11) exp -> exp . + termino
    (12) exp -> exp . - termino

    ;               reduce using rule 16 (expression -> exp EQ exp .)
    ,               reduce using rule 16 (expression -> exp EQ exp .)
    )               reduce using rule 16 (expression -> exp EQ exp .)
    +               shift and go to state 89
    -               shift and go to state 90


state 115

    (17) expression -> exp GE exp .
    (11) exp -> exp . + termino
    (12) exp -> exp . - termino

    ;               reduce using rule 17 (expression -> exp GE exp .)
    ,               reduce using rule 17 (expression -> exp GE exp .)
    )               reduce using rule 17 (expression -> exp GE exp .)
    +               shift and go to state 89
    -               shift and go to state 90


state 116

    (18) expression -> exp LE exp .
    (11) exp -> exp . + termino
    (12) exp -> exp . - termino

    ;               reduce using rule 18 (expression -> exp LE exp .)
    ,               reduce using rule 18 (expression -> exp LE exp .)
    )               reduce using rule 18 (expression -> exp LE exp .)
    +               shift and go to state 89
    -               shift and go to state 90


state 117

    (19) expression -> exp NE exp .
    (11) exp -> exp . + termino
    (12) exp -> exp . - termino

    ;               reduce using rule 19 (expression -> exp NE exp .)
    ,               reduce using rule 19 (expression -> exp NE exp .)
    )               reduce using rule 19 (expression -> exp NE exp .)
    +               shift and go to state 89
    -               shift and go to state 90


state 118

    (11) exp -> exp + termino .
    (33) termino -> termino . * factor
    (34) termino -> termino . / factor

    >               reduce using rule 11 (exp -> exp + termino .)
    <               reduce using rule 11 (exp -> exp + termino .)
    EQ              reduce using rule 11 (exp -> exp + termino .)
    GE              reduce using rule 11 (exp -> exp + termino .)
    LE              reduce using rule 11 (exp -> exp + termino .)
    NE              reduce using rule 11 (exp -> exp + termino .)
    +               reduce using rule 11 (exp -> exp + termino .)
    -               reduce using rule 11 (exp -> exp + termino .)
    ;               reduce using rule 11 (exp -> exp + termino .)
    ,               reduce using rule 11 (exp -> exp + termino .)
    )               reduce using rule 11 (exp -> exp + termino .)
    *               shift and go to state 93
    /               shift and go to state 94


state 119

    (12) exp -> exp - termino .
    (33) termino -> termino . * factor
    (34) termino -> termino . / factor

    >               reduce using rule 12 (exp -> exp - termino .)
    <               reduce using rule 12 (exp -> exp - termino .)
    EQ              reduce using rule 12 (exp -> exp - termino .)
    GE              reduce using rule 12 (exp -> exp - termino .)
    LE              reduce using rule 12 (exp -> exp - termino .)
    NE              reduce using rule 12 (exp -> exp - termino .)
    +               reduce using rule 12 (exp -> exp - termino .)
    -               reduce using rule 12 (exp -> exp - termino .)
    ;               reduce using rule 12 (exp -> exp - termino .)
    ,               reduce using rule 12 (exp -> exp - termino .)
    )               reduce using rule 12 (exp -> exp - termino .)
    *               shift and go to state 93
    /               shift and go to state 94


state 120

    (33) termino -> termino * factor .

    *               reduce using rule 33 (termino -> termino * factor .)
    /               reduce using rule 33 (termino -> termino * factor .)
    >               reduce using rule 33 (termino -> termino * factor .)
    <               reduce using rule 33 (termino -> termino * factor .)
    EQ              reduce using rule 33 (termino -> termino * factor .)
    GE              reduce using rule 33 (termino -> termino * factor .)
    LE              reduce using rule 33 (termino -> termino * factor .)
    NE              reduce using rule 33 (termino -> termino * factor .)
    +               reduce using rule 33 (termino -> termino * factor .)
    -               reduce using rule 33 (termino -> termino * factor .)
    ;               reduce using rule 33 (termino -> termino * factor .)
    ,               reduce using rule 33 (termino -> termino * factor .)
    )               reduce using rule 33 (termino -> termino * factor .)


state 121

    (34) termino -> termino / factor .

    *               reduce using rule 34 (termino -> termino / factor .)
    /               reduce using rule 34 (termino -> termino / factor .)
    >               reduce using rule 34 (termino -> termino / factor .)
    <               reduce using rule 34 (termino -> termino / factor .)
    EQ              reduce using rule 34 (termino -> termino / factor .)
    GE              reduce using rule 34 (termino -> termino / factor .)
    LE              reduce using rule 34 (termino -> termino / factor .)
    NE              reduce using rule 34 (termino -> termino / factor .)
    +               reduce using rule 34 (termino -> termino / factor .)
    -               reduce using rule 34 (termino -> termino / factor .)
    ;               reduce using rule 34 (termino -> termino / factor .)
    ,               reduce using rule 34 (termino -> termino / factor .)
    )               reduce using rule 34 (termino -> termino / factor .)


state 122

    (21) factor -> ( expression ) .

    *               reduce using rule 21 (factor -> ( expression ) .)
    /               reduce using rule 21 (factor -> ( expression ) .)
    >               reduce using rule 21 (factor -> ( expression ) .)
    <               reduce using rule 21 (factor -> ( expression ) .)
    EQ              reduce using rule 21 (factor -> ( expression ) .)
    GE              reduce using rule 21 (factor -> ( expression ) .)
    LE              reduce using rule 21 (factor -> ( expression ) .)
    NE              reduce using rule 21 (factor -> ( expression ) .)
    +               reduce using rule 21 (factor -> ( expression ) .)
    -               reduce using rule 21 (factor -> ( expression ) .)
    ;               reduce using rule 21 (factor -> ( expression ) .)
    ,               reduce using rule 21 (factor -> ( expression ) .)
    )               reduce using rule 21 (factor -> ( expression ) .)


state 123

    (46) f_call -> ID ( expression f_call_ayuda ) . ;

    ;               shift and go to state 135


state 124

    (48) f_call_ayuda -> , expression . f_call_ayuda
    (48) f_call_ayuda -> . , expression f_call_ayuda
    (49) f_call_ayuda -> . empty
    (1) empty -> .

    ,               shift and go to state 99
    )               reduce using rule 1 (empty -> .)

    f_call_ayuda                   shift and go to state 136
    empty                          shift and go to state 100

state 125

    (39) condition -> IF ( expression ) marcar_if_inicio . body ;
    (40) condition -> IF ( expression ) marcar_if_inicio . body marcar_if_final ELSE marcar_else_inicio body marcar_else_final ;
    (57) body -> . { statements }

    {               shift and go to state 24

    body                           shift and go to state 137

state 126

    (36) cycle -> DO marcar_cycle_inicio body marcar_cycle_final WHILE . ( expression ) ;

    (               shift and go to state 138


state 127

    (28) print -> PRINT ( expression print_ayuda ) . ;

    ;               shift and go to state 139


state 128

    (30) print_ayuda -> , expression . print_ayuda
    (30) print_ayuda -> . , expression print_ayuda
    (31) print_ayuda -> . , CONST_STRING print_ayuda
    (32) print_ayuda -> . empty
    (1) empty -> .

    ,               shift and go to state 105
    )               reduce using rule 1 (empty -> .)

    print_ayuda                    shift and go to state 140
    empty                          shift and go to state 106

state 129

    (31) print_ayuda -> , CONST_STRING . print_ayuda
    (60) cte -> CONST_STRING .
    (30) print_ayuda -> . , expression print_ayuda
    (31) print_ayuda -> . , CONST_STRING print_ayuda
    (32) print_ayuda -> . empty
    (1) empty -> .

  ! shift/reduce conflict for , resolved as shift
  ! reduce/reduce conflict for ) resolved using rule 1 (empty -> .)
    *               reduce using rule 60 (cte -> CONST_STRING .)
    /               reduce using rule 60 (cte -> CONST_STRING .)
    >               reduce using rule 60 (cte -> CONST_STRING .)
    <               reduce using rule 60 (cte -> CONST_STRING .)
    EQ              reduce using rule 60 (cte -> CONST_STRING .)
    GE              reduce using rule 60 (cte -> CONST_STRING .)
    LE              reduce using rule 60 (cte -> CONST_STRING .)
    NE              reduce using rule 60 (cte -> CONST_STRING .)
    +               reduce using rule 60 (cte -> CONST_STRING .)
    -               reduce using rule 60 (cte -> CONST_STRING .)
    ,               shift and go to state 105
    )               reduce using rule 1 (empty -> .)

  ! ,               [ reduce using rule 60 (cte -> CONST_STRING .) ]
  ! )               [ reduce using rule 60 (cte -> CONST_STRING .) ]

    print_ayuda                    shift and go to state 141
    empty                          shift and go to state 106

state 130

    (29) print -> PRINT ( CONST_STRING print_ayuda ) . ;

    ;               shift and go to state 142


state 131

    (61) func -> VOID ID ( ID : type funcs_ayuda ) func_start . [ vars body ] ;
    (63) func -> VOID ID ( ID : type funcs_ayuda ) func_start . [ body ] ;

    [               shift and go to state 143


state 132

    (69) funcs_ayuda -> , ID : . type funcs_ayuda
    (2) type -> . INT
    (3) type -> . FLOAT
    (4) type -> . STRING

    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    STRING          shift and go to state 30

    type                           shift and go to state 144

state 133

    (62) func -> VOID ID ( ) func_start [ vars body ] . ;

    ;               shift and go to state 145


state 134

    (64) func -> VOID ID ( ) func_start [ body ] ; .

    MAIN            reduce using rule 64 (func -> VOID ID ( ) func_start [ body ] ; .)
    VOID            reduce using rule 64 (func -> VOID ID ( ) func_start [ body ] ; .)


state 135

    (46) f_call -> ID ( expression f_call_ayuda ) ; .

    }               reduce using rule 46 (f_call -> ID ( expression f_call_ayuda ) ; .)
    ID              reduce using rule 46 (f_call -> ID ( expression f_call_ayuda ) ; .)
    IF              reduce using rule 46 (f_call -> ID ( expression f_call_ayuda ) ; .)
    DO              reduce using rule 46 (f_call -> ID ( expression f_call_ayuda ) ; .)
    PRINT           reduce using rule 46 (f_call -> ID ( expression f_call_ayuda ) ; .)


state 136

    (48) f_call_ayuda -> , expression f_call_ayuda .

    )               reduce using rule 48 (f_call_ayuda -> , expression f_call_ayuda .)


state 137

    (39) condition -> IF ( expression ) marcar_if_inicio body . ;
    (40) condition -> IF ( expression ) marcar_if_inicio body . marcar_if_final ELSE marcar_else_inicio body marcar_else_final ;
    (42) marcar_if_final -> .

    ;               shift and go to state 146
    ELSE            reduce using rule 42 (marcar_if_final -> .)

    marcar_if_final                shift and go to state 147

state 138

    (36) cycle -> DO marcar_cycle_inicio body marcar_cycle_final WHILE ( . expression ) ;
    (14) expression -> . exp > exp
    (15) expression -> . exp < exp
    (16) expression -> . exp EQ exp
    (17) expression -> . exp GE exp
    (18) expression -> . exp LE exp
    (19) expression -> . exp NE exp
    (20) expression -> . exp
    (11) exp -> . exp + termino
    (12) exp -> . exp - termino
    (13) exp -> . termino
    (33) termino -> . termino * factor
    (34) termino -> . termino / factor
    (35) termino -> . factor
    (21) factor -> . ( expression )
    (22) factor -> . ID
    (23) factor -> . cte
    (24) factor -> . + ID
    (25) factor -> . - ID
    (26) factor -> . + cte
    (27) factor -> . - cte
    (58) cte -> . CONST_INT
    (59) cte -> . CONST_FLOAT
    (60) cte -> . CONST_STRING

    (               shift and go to state 66
    ID              shift and go to state 59
    +               shift and go to state 62
    -               shift and go to state 64
    CONST_INT       shift and go to state 68
    CONST_FLOAT     shift and go to state 69
    CONST_STRING    shift and go to state 70

    expression                     shift and go to state 148
    exp                            shift and go to state 61
    termino                        shift and go to state 63
    factor                         shift and go to state 65
    cte                            shift and go to state 67

state 139

    (28) print -> PRINT ( expression print_ayuda ) ; .

    }               reduce using rule 28 (print -> PRINT ( expression print_ayuda ) ; .)
    ID              reduce using rule 28 (print -> PRINT ( expression print_ayuda ) ; .)
    IF              reduce using rule 28 (print -> PRINT ( expression print_ayuda ) ; .)
    DO              reduce using rule 28 (print -> PRINT ( expression print_ayuda ) ; .)
    PRINT           reduce using rule 28 (print -> PRINT ( expression print_ayuda ) ; .)


state 140

    (30) print_ayuda -> , expression print_ayuda .

    )               reduce using rule 30 (print_ayuda -> , expression print_ayuda .)


state 141

    (31) print_ayuda -> , CONST_STRING print_ayuda .

    )               reduce using rule 31 (print_ayuda -> , CONST_STRING print_ayuda .)


state 142

    (29) print -> PRINT ( CONST_STRING print_ayuda ) ; .

    }               reduce using rule 29 (print -> PRINT ( CONST_STRING print_ayuda ) ; .)
    ID              reduce using rule 29 (print -> PRINT ( CONST_STRING print_ayuda ) ; .)
    IF              reduce using rule 29 (print -> PRINT ( CONST_STRING print_ayuda ) ; .)
    DO              reduce using rule 29 (print -> PRINT ( CONST_STRING print_ayuda ) ; .)
    PRINT           reduce using rule 29 (print -> PRINT ( CONST_STRING print_ayuda ) ; .)


state 143

    (61) func -> VOID ID ( ID : type funcs_ayuda ) func_start [ . vars body ] ;
    (63) func -> VOID ID ( ID : type funcs_ayuda ) func_start [ . body ] ;
    (5) vars -> . VAR var_ayuda
    (57) body -> . { statements }

    VAR             shift and go to state 6
    {               shift and go to state 24

    vars                           shift and go to state 149
    body                           shift and go to state 150

state 144

    (69) funcs_ayuda -> , ID : type . funcs_ayuda
    (69) funcs_ayuda -> . , ID : type funcs_ayuda
    (70) funcs_ayuda -> . empty
    (1) empty -> .

    ,               shift and go to state 78
    )               reduce using rule 1 (empty -> .)

    funcs_ayuda                    shift and go to state 151
    empty                          shift and go to state 79

state 145

    (62) func -> VOID ID ( ) func_start [ vars body ] ; .

    MAIN            reduce using rule 62 (func -> VOID ID ( ) func_start [ vars body ] ; .)
    VOID            reduce using rule 62 (func -> VOID ID ( ) func_start [ vars body ] ; .)


state 146

    (39) condition -> IF ( expression ) marcar_if_inicio body ; .

    }               reduce using rule 39 (condition -> IF ( expression ) marcar_if_inicio body ; .)
    ID              reduce using rule 39 (condition -> IF ( expression ) marcar_if_inicio body ; .)
    IF              reduce using rule 39 (condition -> IF ( expression ) marcar_if_inicio body ; .)
    DO              reduce using rule 39 (condition -> IF ( expression ) marcar_if_inicio body ; .)
    PRINT           reduce using rule 39 (condition -> IF ( expression ) marcar_if_inicio body ; .)


state 147

    (40) condition -> IF ( expression ) marcar_if_inicio body marcar_if_final . ELSE marcar_else_inicio body marcar_else_final ;

    ELSE            shift and go to state 152


state 148

    (36) cycle -> DO marcar_cycle_inicio body marcar_cycle_final WHILE ( expression . ) ;

    )               shift and go to state 153


state 149

    (61) func -> VOID ID ( ID : type funcs_ayuda ) func_start [ vars . body ] ;
    (57) body -> . { statements }

    {               shift and go to state 24

    body                           shift and go to state 154

state 150

    (63) func -> VOID ID ( ID : type funcs_ayuda ) func_start [ body . ] ;

    ]               shift and go to state 155


state 151

    (69) funcs_ayuda -> , ID : type funcs_ayuda .

    )               reduce using rule 69 (funcs_ayuda -> , ID : type funcs_ayuda .)


state 152

    (40) condition -> IF ( expression ) marcar_if_inicio body marcar_if_final ELSE . marcar_else_inicio body marcar_else_final ;
    (43) marcar_else_inicio -> .

    {               reduce using rule 43 (marcar_else_inicio -> .)

    marcar_else_inicio             shift and go to state 156

state 153

    (36) cycle -> DO marcar_cycle_inicio body marcar_cycle_final WHILE ( expression ) . ;

    ;               shift and go to state 157


state 154

    (61) func -> VOID ID ( ID : type funcs_ayuda ) func_start [ vars body . ] ;

    ]               shift and go to state 158


state 155

    (63) func -> VOID ID ( ID : type funcs_ayuda ) func_start [ body ] . ;

    ;               shift and go to state 159


state 156

    (40) condition -> IF ( expression ) marcar_if_inicio body marcar_if_final ELSE marcar_else_inicio . body marcar_else_final ;
    (57) body -> . { statements }

    {               shift and go to state 24

    body                           shift and go to state 160

state 157

    (36) cycle -> DO marcar_cycle_inicio body marcar_cycle_final WHILE ( expression ) ; .

    }               reduce using rule 36 (cycle -> DO marcar_cycle_inicio body marcar_cycle_final WHILE ( expression ) ; .)
    ID              reduce using rule 36 (cycle -> DO marcar_cycle_inicio body marcar_cycle_final WHILE ( expression ) ; .)
    IF              reduce using rule 36 (cycle -> DO marcar_cycle_inicio body marcar_cycle_final WHILE ( expression ) ; .)
    DO              reduce using rule 36 (cycle -> DO marcar_cycle_inicio body marcar_cycle_final WHILE ( expression ) ; .)
    PRINT           reduce using rule 36 (cycle -> DO marcar_cycle_inicio body marcar_cycle_final WHILE ( expression ) ; .)


state 158

    (61) func -> VOID ID ( ID : type funcs_ayuda ) func_start [ vars body ] . ;

    ;               shift and go to state 161


state 159

    (63) func -> VOID ID ( ID : type funcs_ayuda ) func_start [ body ] ; .

    MAIN            reduce using rule 63 (func -> VOID ID ( ID : type funcs_ayuda ) func_start [ body ] ; .)
    VOID            reduce using rule 63 (func -> VOID ID ( ID : type funcs_ayuda ) func_start [ body ] ; .)


state 160

    (40) condition -> IF ( expression ) marcar_if_inicio body marcar_if_final ELSE marcar_else_inicio body . marcar_else_final ;
    (44) marcar_else_final -> .

    ;               reduce using rule 44 (marcar_else_final -> .)

    marcar_else_final              shift and go to state 162

state 161

    (61) func -> VOID ID ( ID : type funcs_ayuda ) func_start [ vars body ] ; .

    MAIN            reduce using rule 61 (func -> VOID ID ( ID : type funcs_ayuda ) func_start [ vars body ] ; .)
    VOID            reduce using rule 61 (func -> VOID ID ( ID : type funcs_ayuda ) func_start [ vars body ] ; .)


state 162

    (40) condition -> IF ( expression ) marcar_if_inicio body marcar_if_final ELSE marcar_else_inicio body marcar_else_final . ;

    ;               shift and go to state 163


state 163

    (40) condition -> IF ( expression ) marcar_if_inicio body marcar_if_final ELSE marcar_else_inicio body marcar_else_final ; .

    }               reduce using rule 40 (condition -> IF ( expression ) marcar_if_inicio body marcar_if_final ELSE marcar_else_inicio body marcar_else_final ; .)
    ID              reduce using rule 40 (condition -> IF ( expression ) marcar_if_inicio body marcar_if_final ELSE marcar_else_inicio body marcar_else_final ; .)
    IF              reduce using rule 40 (condition -> IF ( expression ) marcar_if_inicio body marcar_if_final ELSE marcar_else_inicio body marcar_else_final ; .)
    DO              reduce using rule 40 (condition -> IF ( expression ) marcar_if_inicio body marcar_if_final ELSE marcar_else_inicio body marcar_else_final ; .)
    PRINT           reduce using rule 40 (condition -> IF ( expression ) marcar_if_inicio body marcar_if_final ELSE marcar_else_inicio body marcar_else_final ; .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for VOID in state 5 resolved as shift
WARNING: shift/reduce conflict for , in state 76 resolved as shift
WARNING: shift/reduce conflict for , in state 129 resolved as shift
WARNING: reduce/reduce conflict in state 76 resolved using rule (empty -> <empty>)
WARNING: rejected rule (cte -> CONST_STRING) in state 76
WARNING: reduce/reduce conflict in state 129 resolved using rule (empty -> <empty>)
WARNING: rejected rule (cte -> CONST_STRING) in state 129
