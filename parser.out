Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     empty -> <empty>
Rule 2     type -> INT
Rule 3     type -> FLOAT
Rule 4     vars -> VAR var_ayuda
Rule 5     var_ayuda -> ID var_doble_ayuda : type ; var_ayuda_tail
Rule 6     var_ayuda_tail -> var_ayuda
Rule 7     var_ayuda_tail -> empty
Rule 8     var_doble_ayuda -> , ID var_doble_ayuda
Rule 9     var_doble_ayuda -> empty
Rule 10    exp -> exp + termino
Rule 11    exp -> exp - termino
Rule 12    exp -> termino
Rule 13    expression -> exp > exp
Rule 14    expression -> exp < exp
Rule 15    expression -> exp EQ exp
Rule 16    expression -> exp GE exp
Rule 17    expression -> exp LE exp
Rule 18    expression -> exp NE exp
Rule 19    expression -> exp
Rule 20    factor -> ( expression )
Rule 21    factor -> ID
Rule 22    factor -> cte
Rule 23    factor -> + ID
Rule 24    factor -> - ID
Rule 25    factor -> + cte
Rule 26    factor -> - cte
Rule 27    print -> PRINT ( expression print_ayuda ) ;
Rule 28    print -> PRINT ( CONST_STRING print_ayuda ) ;
Rule 29    print_ayuda -> , expression print_ayuda
Rule 30    print_ayuda -> , STRING print_ayuda
Rule 31    print_ayuda -> empty
Rule 32    termino -> termino * factor
Rule 33    termino -> termino / factor
Rule 34    termino -> factor
Rule 35    cycle -> DO body WHILE ( expression ) ;
Rule 36    condition -> IF ( expression ) marcar_if_inicio body ;
Rule 37    marcar_if_inicio -> <empty>
Rule 38    condition -> IF ( expression ) marcar_if_else_inicio body marcar_else_inicio ELSE body ;
Rule 39    marcar_if_else_inicio -> <empty>
Rule 40    marcar_else_inicio -> <empty>
Rule 41    assign -> ID = expression ;
Rule 42    f_call -> ID ( expression f_call_ayuda ) ;
Rule 43    f_call -> ID ( ) ;
Rule 44    f_call_ayuda -> , expression f_call_ayuda
Rule 45    f_call_ayuda -> empty
Rule 46    statements -> statements statement
Rule 47    statements -> statement
Rule 48    statement -> assign
Rule 49    statement -> condition
Rule 50    statement -> cycle
Rule 51    statement -> f_call
Rule 52    statement -> print
Rule 53    body -> { statements }
Rule 54    cte -> CONST_INT
Rule 55    cte -> CONST_FLOAT
Rule 56    funcs -> VOID ID ( ID : type funcs_ayuda ) [ vars body ] ;
Rule 57    funcs -> VOID ID ( ) [ vars body ] ;
Rule 58    funcs -> VOID ID ( ID : type funcs_ayuda ) [ body ] ;
Rule 59    funcs -> VOID ID ( ) [ body ] ;
Rule 60    funcs -> funcs funcs
Rule 61    funcs -> empty
Rule 62    funcs_ayuda -> , ID : type funcs_ayuda
Rule 63    funcs_ayuda -> empty
Rule 64    program -> PROGRAM ID ; vars funcs MAIN body END

Terminals, with rules where they appear

(                    : 20 27 28 35 36 38 42 43 56 57 58 59
)                    : 20 27 28 35 36 38 42 43 56 57 58 59
*                    : 32
+                    : 10 23 25
,                    : 8 29 30 44 62
-                    : 11 24 26
/                    : 33
:                    : 5 56 58 62
;                    : 5 27 28 35 36 38 41 42 43 56 57 58 59 64
<                    : 14
=                    : 41
>                    : 13
CONST_FLOAT          : 55
CONST_INT            : 54
CONST_STRING         : 28
DO                   : 35
ELSE                 : 38
END                  : 64
EQ                   : 15
FLOAT                : 3
GE                   : 16
ID                   : 5 8 21 23 24 41 42 43 56 56 57 58 58 59 62 64
IF                   : 36 38
INT                  : 2
LE                   : 17
MAIN                 : 64
NE                   : 18
PRINT                : 27 28
PROGRAM              : 64
STRING               : 30
VAR                  : 4
VOID                 : 56 57 58 59
WHILE                : 35
[                    : 56 57 58 59
]                    : 56 57 58 59
error                : 
{                    : 53
}                    : 53

Nonterminals, with rules where they appear

assign               : 48
body                 : 35 36 38 38 56 57 58 59 64
condition            : 49
cte                  : 22 25 26
cycle                : 50
empty                : 7 9 31 45 61 63
exp                  : 10 11 13 13 14 14 15 15 16 16 17 17 18 18 19
expression           : 20 27 29 35 36 38 41 42 44
f_call               : 51
f_call_ayuda         : 42 44
factor               : 32 33 34
funcs                : 60 60 64
funcs_ayuda          : 56 58 62
marcar_else_inicio   : 38
marcar_if_else_inicio : 38
marcar_if_inicio     : 36
print                : 52
print_ayuda          : 27 28 29 30
program              : 0
statement            : 46 47
statements           : 46 53
termino              : 10 11 12 32 33
type                 : 5 56 58 62
var_ayuda            : 4 6
var_ayuda_tail       : 5
var_doble_ayuda      : 5 8
vars                 : 56 57 64

Parsing method: LALR

state 0

    (0) S' -> . program
    (64) program -> . PROGRAM ID ; vars funcs MAIN body END

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (64) program -> PROGRAM . ID ; vars funcs MAIN body END

    ID              shift and go to state 3


state 3

    (64) program -> PROGRAM ID . ; vars funcs MAIN body END

    ;               shift and go to state 4


state 4

    (64) program -> PROGRAM ID ; . vars funcs MAIN body END
    (4) vars -> . VAR var_ayuda

    VAR             shift and go to state 6

    vars                           shift and go to state 5

state 5

    (64) program -> PROGRAM ID ; vars . funcs MAIN body END
    (56) funcs -> . VOID ID ( ID : type funcs_ayuda ) [ vars body ] ;
    (57) funcs -> . VOID ID ( ) [ vars body ] ;
    (58) funcs -> . VOID ID ( ID : type funcs_ayuda ) [ body ] ;
    (59) funcs -> . VOID ID ( ) [ body ] ;
    (60) funcs -> . funcs funcs
    (61) funcs -> . empty
    (1) empty -> .

  ! shift/reduce conflict for VOID resolved as shift
    VOID            shift and go to state 8
    MAIN            reduce using rule 1 (empty -> .)

  ! VOID            [ reduce using rule 1 (empty -> .) ]

    funcs                          shift and go to state 7
    empty                          shift and go to state 9

state 6

    (4) vars -> VAR . var_ayuda
    (5) var_ayuda -> . ID var_doble_ayuda : type ; var_ayuda_tail

    ID              shift and go to state 11

    var_ayuda                      shift and go to state 10

state 7

    (64) program -> PROGRAM ID ; vars funcs . MAIN body END
    (60) funcs -> funcs . funcs
    (56) funcs -> . VOID ID ( ID : type funcs_ayuda ) [ vars body ] ;
    (57) funcs -> . VOID ID ( ) [ vars body ] ;
    (58) funcs -> . VOID ID ( ID : type funcs_ayuda ) [ body ] ;
    (59) funcs -> . VOID ID ( ) [ body ] ;
    (60) funcs -> . funcs funcs
    (61) funcs -> . empty
    (1) empty -> .

  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for MAIN resolved as shift
    MAIN            shift and go to state 13
    VOID            shift and go to state 8

  ! VOID            [ reduce using rule 1 (empty -> .) ]
  ! MAIN            [ reduce using rule 1 (empty -> .) ]

    funcs                          shift and go to state 12
    empty                          shift and go to state 9

state 8

    (56) funcs -> VOID . ID ( ID : type funcs_ayuda ) [ vars body ] ;
    (57) funcs -> VOID . ID ( ) [ vars body ] ;
    (58) funcs -> VOID . ID ( ID : type funcs_ayuda ) [ body ] ;
    (59) funcs -> VOID . ID ( ) [ body ] ;

    ID              shift and go to state 14


state 9

    (61) funcs -> empty .

    MAIN            reduce using rule 61 (funcs -> empty .)
    VOID            reduce using rule 61 (funcs -> empty .)


state 10

    (4) vars -> VAR var_ayuda .

    VOID            reduce using rule 4 (vars -> VAR var_ayuda .)
    MAIN            reduce using rule 4 (vars -> VAR var_ayuda .)
    {               reduce using rule 4 (vars -> VAR var_ayuda .)


state 11

    (5) var_ayuda -> ID . var_doble_ayuda : type ; var_ayuda_tail
    (8) var_doble_ayuda -> . , ID var_doble_ayuda
    (9) var_doble_ayuda -> . empty
    (1) empty -> .

    ,               shift and go to state 16
    :               reduce using rule 1 (empty -> .)

    var_doble_ayuda                shift and go to state 15
    empty                          shift and go to state 17

state 12

    (60) funcs -> funcs funcs .
    (60) funcs -> funcs . funcs
    (56) funcs -> . VOID ID ( ID : type funcs_ayuda ) [ vars body ] ;
    (57) funcs -> . VOID ID ( ) [ vars body ] ;
    (58) funcs -> . VOID ID ( ID : type funcs_ayuda ) [ body ] ;
    (59) funcs -> . VOID ID ( ) [ body ] ;
    (60) funcs -> . funcs funcs
    (61) funcs -> . empty
    (1) empty -> .

  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! reduce/reduce conflict for MAIN resolved using rule 1 (empty -> .)
    VOID            shift and go to state 8
    MAIN            reduce using rule 1 (empty -> .)

  ! MAIN            [ reduce using rule 60 (funcs -> funcs funcs .) ]
  ! VOID            [ reduce using rule 60 (funcs -> funcs funcs .) ]
  ! VOID            [ reduce using rule 1 (empty -> .) ]

    funcs                          shift and go to state 12
    empty                          shift and go to state 9

state 13

    (64) program -> PROGRAM ID ; vars funcs MAIN . body END
    (53) body -> . { statements }

    {               shift and go to state 19

    body                           shift and go to state 18

state 14

    (56) funcs -> VOID ID . ( ID : type funcs_ayuda ) [ vars body ] ;
    (57) funcs -> VOID ID . ( ) [ vars body ] ;
    (58) funcs -> VOID ID . ( ID : type funcs_ayuda ) [ body ] ;
    (59) funcs -> VOID ID . ( ) [ body ] ;

    (               shift and go to state 20


state 15

    (5) var_ayuda -> ID var_doble_ayuda . : type ; var_ayuda_tail

    :               shift and go to state 21


state 16

    (8) var_doble_ayuda -> , . ID var_doble_ayuda

    ID              shift and go to state 22


state 17

    (9) var_doble_ayuda -> empty .

    :               reduce using rule 9 (var_doble_ayuda -> empty .)


state 18

    (64) program -> PROGRAM ID ; vars funcs MAIN body . END

    END             shift and go to state 23


state 19

    (53) body -> { . statements }
    (46) statements -> . statements statement
    (47) statements -> . statement
    (48) statement -> . assign
    (49) statement -> . condition
    (50) statement -> . cycle
    (51) statement -> . f_call
    (52) statement -> . print
    (41) assign -> . ID = expression ;
    (36) condition -> . IF ( expression ) marcar_if_inicio body ;
    (38) condition -> . IF ( expression ) marcar_if_else_inicio body marcar_else_inicio ELSE body ;
    (35) cycle -> . DO body WHILE ( expression ) ;
    (42) f_call -> . ID ( expression f_call_ayuda ) ;
    (43) f_call -> . ID ( ) ;
    (27) print -> . PRINT ( expression print_ayuda ) ;
    (28) print -> . PRINT ( CONST_STRING print_ayuda ) ;

    ID              shift and go to state 31
    IF              shift and go to state 32
    DO              shift and go to state 33
    PRINT           shift and go to state 34

    statements                     shift and go to state 24
    statement                      shift and go to state 25
    assign                         shift and go to state 26
    condition                      shift and go to state 27
    cycle                          shift and go to state 28
    f_call                         shift and go to state 29
    print                          shift and go to state 30

state 20

    (56) funcs -> VOID ID ( . ID : type funcs_ayuda ) [ vars body ] ;
    (57) funcs -> VOID ID ( . ) [ vars body ] ;
    (58) funcs -> VOID ID ( . ID : type funcs_ayuda ) [ body ] ;
    (59) funcs -> VOID ID ( . ) [ body ] ;

    ID              shift and go to state 35
    )               shift and go to state 36


state 21

    (5) var_ayuda -> ID var_doble_ayuda : . type ; var_ayuda_tail
    (2) type -> . INT
    (3) type -> . FLOAT

    INT             shift and go to state 38
    FLOAT           shift and go to state 39

    type                           shift and go to state 37

state 22

    (8) var_doble_ayuda -> , ID . var_doble_ayuda
    (8) var_doble_ayuda -> . , ID var_doble_ayuda
    (9) var_doble_ayuda -> . empty
    (1) empty -> .

    ,               shift and go to state 16
    :               reduce using rule 1 (empty -> .)

    var_doble_ayuda                shift and go to state 40
    empty                          shift and go to state 17

state 23

    (64) program -> PROGRAM ID ; vars funcs MAIN body END .

    $end            reduce using rule 64 (program -> PROGRAM ID ; vars funcs MAIN body END .)


state 24

    (53) body -> { statements . }
    (46) statements -> statements . statement
    (48) statement -> . assign
    (49) statement -> . condition
    (50) statement -> . cycle
    (51) statement -> . f_call
    (52) statement -> . print
    (41) assign -> . ID = expression ;
    (36) condition -> . IF ( expression ) marcar_if_inicio body ;
    (38) condition -> . IF ( expression ) marcar_if_else_inicio body marcar_else_inicio ELSE body ;
    (35) cycle -> . DO body WHILE ( expression ) ;
    (42) f_call -> . ID ( expression f_call_ayuda ) ;
    (43) f_call -> . ID ( ) ;
    (27) print -> . PRINT ( expression print_ayuda ) ;
    (28) print -> . PRINT ( CONST_STRING print_ayuda ) ;

    }               shift and go to state 41
    ID              shift and go to state 31
    IF              shift and go to state 32
    DO              shift and go to state 33
    PRINT           shift and go to state 34

    statement                      shift and go to state 42
    assign                         shift and go to state 26
    condition                      shift and go to state 27
    cycle                          shift and go to state 28
    f_call                         shift and go to state 29
    print                          shift and go to state 30

state 25

    (47) statements -> statement .

    }               reduce using rule 47 (statements -> statement .)
    ID              reduce using rule 47 (statements -> statement .)
    IF              reduce using rule 47 (statements -> statement .)
    DO              reduce using rule 47 (statements -> statement .)
    PRINT           reduce using rule 47 (statements -> statement .)


state 26

    (48) statement -> assign .

    }               reduce using rule 48 (statement -> assign .)
    ID              reduce using rule 48 (statement -> assign .)
    IF              reduce using rule 48 (statement -> assign .)
    DO              reduce using rule 48 (statement -> assign .)
    PRINT           reduce using rule 48 (statement -> assign .)


state 27

    (49) statement -> condition .

    }               reduce using rule 49 (statement -> condition .)
    ID              reduce using rule 49 (statement -> condition .)
    IF              reduce using rule 49 (statement -> condition .)
    DO              reduce using rule 49 (statement -> condition .)
    PRINT           reduce using rule 49 (statement -> condition .)


state 28

    (50) statement -> cycle .

    }               reduce using rule 50 (statement -> cycle .)
    ID              reduce using rule 50 (statement -> cycle .)
    IF              reduce using rule 50 (statement -> cycle .)
    DO              reduce using rule 50 (statement -> cycle .)
    PRINT           reduce using rule 50 (statement -> cycle .)


state 29

    (51) statement -> f_call .

    }               reduce using rule 51 (statement -> f_call .)
    ID              reduce using rule 51 (statement -> f_call .)
    IF              reduce using rule 51 (statement -> f_call .)
    DO              reduce using rule 51 (statement -> f_call .)
    PRINT           reduce using rule 51 (statement -> f_call .)


state 30

    (52) statement -> print .

    }               reduce using rule 52 (statement -> print .)
    ID              reduce using rule 52 (statement -> print .)
    IF              reduce using rule 52 (statement -> print .)
    DO              reduce using rule 52 (statement -> print .)
    PRINT           reduce using rule 52 (statement -> print .)


state 31

    (41) assign -> ID . = expression ;
    (42) f_call -> ID . ( expression f_call_ayuda ) ;
    (43) f_call -> ID . ( ) ;

    =               shift and go to state 43
    (               shift and go to state 44


state 32

    (36) condition -> IF . ( expression ) marcar_if_inicio body ;
    (38) condition -> IF . ( expression ) marcar_if_else_inicio body marcar_else_inicio ELSE body ;

    (               shift and go to state 45


state 33

    (35) cycle -> DO . body WHILE ( expression ) ;
    (53) body -> . { statements }

    {               shift and go to state 19

    body                           shift and go to state 46

state 34

    (27) print -> PRINT . ( expression print_ayuda ) ;
    (28) print -> PRINT . ( CONST_STRING print_ayuda ) ;

    (               shift and go to state 47


state 35

    (56) funcs -> VOID ID ( ID . : type funcs_ayuda ) [ vars body ] ;
    (58) funcs -> VOID ID ( ID . : type funcs_ayuda ) [ body ] ;

    :               shift and go to state 48


state 36

    (57) funcs -> VOID ID ( ) . [ vars body ] ;
    (59) funcs -> VOID ID ( ) . [ body ] ;

    [               shift and go to state 49


state 37

    (5) var_ayuda -> ID var_doble_ayuda : type . ; var_ayuda_tail

    ;               shift and go to state 50


state 38

    (2) type -> INT .

    ;               reduce using rule 2 (type -> INT .)
    ,               reduce using rule 2 (type -> INT .)
    )               reduce using rule 2 (type -> INT .)


state 39

    (3) type -> FLOAT .

    ;               reduce using rule 3 (type -> FLOAT .)
    ,               reduce using rule 3 (type -> FLOAT .)
    )               reduce using rule 3 (type -> FLOAT .)


state 40

    (8) var_doble_ayuda -> , ID var_doble_ayuda .

    :               reduce using rule 8 (var_doble_ayuda -> , ID var_doble_ayuda .)


state 41

    (53) body -> { statements } .

    END             reduce using rule 53 (body -> { statements } .)
    WHILE           reduce using rule 53 (body -> { statements } .)
    ]               reduce using rule 53 (body -> { statements } .)
    ;               reduce using rule 53 (body -> { statements } .)
    ELSE            reduce using rule 53 (body -> { statements } .)


state 42

    (46) statements -> statements statement .

    }               reduce using rule 46 (statements -> statements statement .)
    ID              reduce using rule 46 (statements -> statements statement .)
    IF              reduce using rule 46 (statements -> statements statement .)
    DO              reduce using rule 46 (statements -> statements statement .)
    PRINT           reduce using rule 46 (statements -> statements statement .)


state 43

    (41) assign -> ID = . expression ;
    (13) expression -> . exp > exp
    (14) expression -> . exp < exp
    (15) expression -> . exp EQ exp
    (16) expression -> . exp GE exp
    (17) expression -> . exp LE exp
    (18) expression -> . exp NE exp
    (19) expression -> . exp
    (10) exp -> . exp + termino
    (11) exp -> . exp - termino
    (12) exp -> . termino
    (32) termino -> . termino * factor
    (33) termino -> . termino / factor
    (34) termino -> . factor
    (20) factor -> . ( expression )
    (21) factor -> . ID
    (22) factor -> . cte
    (23) factor -> . + ID
    (24) factor -> . - ID
    (25) factor -> . + cte
    (26) factor -> . - cte
    (54) cte -> . CONST_INT
    (55) cte -> . CONST_FLOAT

    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    expression                     shift and go to state 52
    exp                            shift and go to state 53
    termino                        shift and go to state 55
    factor                         shift and go to state 57
    cte                            shift and go to state 59

state 44

    (42) f_call -> ID ( . expression f_call_ayuda ) ;
    (43) f_call -> ID ( . ) ;
    (13) expression -> . exp > exp
    (14) expression -> . exp < exp
    (15) expression -> . exp EQ exp
    (16) expression -> . exp GE exp
    (17) expression -> . exp LE exp
    (18) expression -> . exp NE exp
    (19) expression -> . exp
    (10) exp -> . exp + termino
    (11) exp -> . exp - termino
    (12) exp -> . termino
    (32) termino -> . termino * factor
    (33) termino -> . termino / factor
    (34) termino -> . factor
    (20) factor -> . ( expression )
    (21) factor -> . ID
    (22) factor -> . cte
    (23) factor -> . + ID
    (24) factor -> . - ID
    (25) factor -> . + cte
    (26) factor -> . - cte
    (54) cte -> . CONST_INT
    (55) cte -> . CONST_FLOAT

    )               shift and go to state 63
    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    expression                     shift and go to state 62
    exp                            shift and go to state 53
    termino                        shift and go to state 55
    factor                         shift and go to state 57
    cte                            shift and go to state 59

state 45

    (36) condition -> IF ( . expression ) marcar_if_inicio body ;
    (38) condition -> IF ( . expression ) marcar_if_else_inicio body marcar_else_inicio ELSE body ;
    (13) expression -> . exp > exp
    (14) expression -> . exp < exp
    (15) expression -> . exp EQ exp
    (16) expression -> . exp GE exp
    (17) expression -> . exp LE exp
    (18) expression -> . exp NE exp
    (19) expression -> . exp
    (10) exp -> . exp + termino
    (11) exp -> . exp - termino
    (12) exp -> . termino
    (32) termino -> . termino * factor
    (33) termino -> . termino / factor
    (34) termino -> . factor
    (20) factor -> . ( expression )
    (21) factor -> . ID
    (22) factor -> . cte
    (23) factor -> . + ID
    (24) factor -> . - ID
    (25) factor -> . + cte
    (26) factor -> . - cte
    (54) cte -> . CONST_INT
    (55) cte -> . CONST_FLOAT

    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    expression                     shift and go to state 64
    exp                            shift and go to state 53
    termino                        shift and go to state 55
    factor                         shift and go to state 57
    cte                            shift and go to state 59

state 46

    (35) cycle -> DO body . WHILE ( expression ) ;

    WHILE           shift and go to state 65


state 47

    (27) print -> PRINT ( . expression print_ayuda ) ;
    (28) print -> PRINT ( . CONST_STRING print_ayuda ) ;
    (13) expression -> . exp > exp
    (14) expression -> . exp < exp
    (15) expression -> . exp EQ exp
    (16) expression -> . exp GE exp
    (17) expression -> . exp LE exp
    (18) expression -> . exp NE exp
    (19) expression -> . exp
    (10) exp -> . exp + termino
    (11) exp -> . exp - termino
    (12) exp -> . termino
    (32) termino -> . termino * factor
    (33) termino -> . termino / factor
    (34) termino -> . factor
    (20) factor -> . ( expression )
    (21) factor -> . ID
    (22) factor -> . cte
    (23) factor -> . + ID
    (24) factor -> . - ID
    (25) factor -> . + cte
    (26) factor -> . - cte
    (54) cte -> . CONST_INT
    (55) cte -> . CONST_FLOAT

    CONST_STRING    shift and go to state 67
    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    expression                     shift and go to state 66
    exp                            shift and go to state 53
    termino                        shift and go to state 55
    factor                         shift and go to state 57
    cte                            shift and go to state 59

state 48

    (56) funcs -> VOID ID ( ID : . type funcs_ayuda ) [ vars body ] ;
    (58) funcs -> VOID ID ( ID : . type funcs_ayuda ) [ body ] ;
    (2) type -> . INT
    (3) type -> . FLOAT

    INT             shift and go to state 38
    FLOAT           shift and go to state 39

    type                           shift and go to state 68

state 49

    (57) funcs -> VOID ID ( ) [ . vars body ] ;
    (59) funcs -> VOID ID ( ) [ . body ] ;
    (4) vars -> . VAR var_ayuda
    (53) body -> . { statements }

    VAR             shift and go to state 6
    {               shift and go to state 19

    vars                           shift and go to state 69
    body                           shift and go to state 70

state 50

    (5) var_ayuda -> ID var_doble_ayuda : type ; . var_ayuda_tail
    (6) var_ayuda_tail -> . var_ayuda
    (7) var_ayuda_tail -> . empty
    (5) var_ayuda -> . ID var_doble_ayuda : type ; var_ayuda_tail
    (1) empty -> .

    ID              shift and go to state 11
    VOID            reduce using rule 1 (empty -> .)
    MAIN            reduce using rule 1 (empty -> .)
    {               reduce using rule 1 (empty -> .)

    var_ayuda_tail                 shift and go to state 71
    var_ayuda                      shift and go to state 72
    empty                          shift and go to state 73

state 51

    (21) factor -> ID .

    *               reduce using rule 21 (factor -> ID .)
    /               reduce using rule 21 (factor -> ID .)
    >               reduce using rule 21 (factor -> ID .)
    <               reduce using rule 21 (factor -> ID .)
    EQ              reduce using rule 21 (factor -> ID .)
    GE              reduce using rule 21 (factor -> ID .)
    LE              reduce using rule 21 (factor -> ID .)
    NE              reduce using rule 21 (factor -> ID .)
    +               reduce using rule 21 (factor -> ID .)
    -               reduce using rule 21 (factor -> ID .)
    ;               reduce using rule 21 (factor -> ID .)
    ,               reduce using rule 21 (factor -> ID .)
    )               reduce using rule 21 (factor -> ID .)


state 52

    (41) assign -> ID = expression . ;

    ;               shift and go to state 74


state 53

    (13) expression -> exp . > exp
    (14) expression -> exp . < exp
    (15) expression -> exp . EQ exp
    (16) expression -> exp . GE exp
    (17) expression -> exp . LE exp
    (18) expression -> exp . NE exp
    (19) expression -> exp .
    (10) exp -> exp . + termino
    (11) exp -> exp . - termino

    >               shift and go to state 75
    <               shift and go to state 76
    EQ              shift and go to state 77
    GE              shift and go to state 78
    LE              shift and go to state 79
    NE              shift and go to state 80
    ;               reduce using rule 19 (expression -> exp .)
    ,               reduce using rule 19 (expression -> exp .)
    )               reduce using rule 19 (expression -> exp .)
    +               shift and go to state 81
    -               shift and go to state 82


state 54

    (23) factor -> + . ID
    (25) factor -> + . cte
    (54) cte -> . CONST_INT
    (55) cte -> . CONST_FLOAT

    ID              shift and go to state 83
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    cte                            shift and go to state 84

state 55

    (12) exp -> termino .
    (32) termino -> termino . * factor
    (33) termino -> termino . / factor

    >               reduce using rule 12 (exp -> termino .)
    <               reduce using rule 12 (exp -> termino .)
    EQ              reduce using rule 12 (exp -> termino .)
    GE              reduce using rule 12 (exp -> termino .)
    LE              reduce using rule 12 (exp -> termino .)
    NE              reduce using rule 12 (exp -> termino .)
    +               reduce using rule 12 (exp -> termino .)
    -               reduce using rule 12 (exp -> termino .)
    ;               reduce using rule 12 (exp -> termino .)
    ,               reduce using rule 12 (exp -> termino .)
    )               reduce using rule 12 (exp -> termino .)
    *               shift and go to state 85
    /               shift and go to state 86


state 56

    (24) factor -> - . ID
    (26) factor -> - . cte
    (54) cte -> . CONST_INT
    (55) cte -> . CONST_FLOAT

    ID              shift and go to state 87
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    cte                            shift and go to state 88

state 57

    (34) termino -> factor .

    *               reduce using rule 34 (termino -> factor .)
    /               reduce using rule 34 (termino -> factor .)
    >               reduce using rule 34 (termino -> factor .)
    <               reduce using rule 34 (termino -> factor .)
    EQ              reduce using rule 34 (termino -> factor .)
    GE              reduce using rule 34 (termino -> factor .)
    LE              reduce using rule 34 (termino -> factor .)
    NE              reduce using rule 34 (termino -> factor .)
    +               reduce using rule 34 (termino -> factor .)
    -               reduce using rule 34 (termino -> factor .)
    ;               reduce using rule 34 (termino -> factor .)
    ,               reduce using rule 34 (termino -> factor .)
    )               reduce using rule 34 (termino -> factor .)


state 58

    (20) factor -> ( . expression )
    (13) expression -> . exp > exp
    (14) expression -> . exp < exp
    (15) expression -> . exp EQ exp
    (16) expression -> . exp GE exp
    (17) expression -> . exp LE exp
    (18) expression -> . exp NE exp
    (19) expression -> . exp
    (10) exp -> . exp + termino
    (11) exp -> . exp - termino
    (12) exp -> . termino
    (32) termino -> . termino * factor
    (33) termino -> . termino / factor
    (34) termino -> . factor
    (20) factor -> . ( expression )
    (21) factor -> . ID
    (22) factor -> . cte
    (23) factor -> . + ID
    (24) factor -> . - ID
    (25) factor -> . + cte
    (26) factor -> . - cte
    (54) cte -> . CONST_INT
    (55) cte -> . CONST_FLOAT

    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    expression                     shift and go to state 89
    exp                            shift and go to state 53
    termino                        shift and go to state 55
    factor                         shift and go to state 57
    cte                            shift and go to state 59

state 59

    (22) factor -> cte .

    *               reduce using rule 22 (factor -> cte .)
    /               reduce using rule 22 (factor -> cte .)
    >               reduce using rule 22 (factor -> cte .)
    <               reduce using rule 22 (factor -> cte .)
    EQ              reduce using rule 22 (factor -> cte .)
    GE              reduce using rule 22 (factor -> cte .)
    LE              reduce using rule 22 (factor -> cte .)
    NE              reduce using rule 22 (factor -> cte .)
    +               reduce using rule 22 (factor -> cte .)
    -               reduce using rule 22 (factor -> cte .)
    ;               reduce using rule 22 (factor -> cte .)
    ,               reduce using rule 22 (factor -> cte .)
    )               reduce using rule 22 (factor -> cte .)


state 60

    (54) cte -> CONST_INT .

    *               reduce using rule 54 (cte -> CONST_INT .)
    /               reduce using rule 54 (cte -> CONST_INT .)
    >               reduce using rule 54 (cte -> CONST_INT .)
    <               reduce using rule 54 (cte -> CONST_INT .)
    EQ              reduce using rule 54 (cte -> CONST_INT .)
    GE              reduce using rule 54 (cte -> CONST_INT .)
    LE              reduce using rule 54 (cte -> CONST_INT .)
    NE              reduce using rule 54 (cte -> CONST_INT .)
    +               reduce using rule 54 (cte -> CONST_INT .)
    -               reduce using rule 54 (cte -> CONST_INT .)
    ;               reduce using rule 54 (cte -> CONST_INT .)
    ,               reduce using rule 54 (cte -> CONST_INT .)
    )               reduce using rule 54 (cte -> CONST_INT .)


state 61

    (55) cte -> CONST_FLOAT .

    *               reduce using rule 55 (cte -> CONST_FLOAT .)
    /               reduce using rule 55 (cte -> CONST_FLOAT .)
    >               reduce using rule 55 (cte -> CONST_FLOAT .)
    <               reduce using rule 55 (cte -> CONST_FLOAT .)
    EQ              reduce using rule 55 (cte -> CONST_FLOAT .)
    GE              reduce using rule 55 (cte -> CONST_FLOAT .)
    LE              reduce using rule 55 (cte -> CONST_FLOAT .)
    NE              reduce using rule 55 (cte -> CONST_FLOAT .)
    +               reduce using rule 55 (cte -> CONST_FLOAT .)
    -               reduce using rule 55 (cte -> CONST_FLOAT .)
    ;               reduce using rule 55 (cte -> CONST_FLOAT .)
    ,               reduce using rule 55 (cte -> CONST_FLOAT .)
    )               reduce using rule 55 (cte -> CONST_FLOAT .)


state 62

    (42) f_call -> ID ( expression . f_call_ayuda ) ;
    (44) f_call_ayuda -> . , expression f_call_ayuda
    (45) f_call_ayuda -> . empty
    (1) empty -> .

    ,               shift and go to state 91
    )               reduce using rule 1 (empty -> .)

    f_call_ayuda                   shift and go to state 90
    empty                          shift and go to state 92

state 63

    (43) f_call -> ID ( ) . ;

    ;               shift and go to state 93


state 64

    (36) condition -> IF ( expression . ) marcar_if_inicio body ;
    (38) condition -> IF ( expression . ) marcar_if_else_inicio body marcar_else_inicio ELSE body ;

    )               shift and go to state 94


state 65

    (35) cycle -> DO body WHILE . ( expression ) ;

    (               shift and go to state 95


state 66

    (27) print -> PRINT ( expression . print_ayuda ) ;
    (29) print_ayuda -> . , expression print_ayuda
    (30) print_ayuda -> . , STRING print_ayuda
    (31) print_ayuda -> . empty
    (1) empty -> .

    ,               shift and go to state 97
    )               reduce using rule 1 (empty -> .)

    print_ayuda                    shift and go to state 96
    empty                          shift and go to state 98

state 67

    (28) print -> PRINT ( CONST_STRING . print_ayuda ) ;
    (29) print_ayuda -> . , expression print_ayuda
    (30) print_ayuda -> . , STRING print_ayuda
    (31) print_ayuda -> . empty
    (1) empty -> .

    ,               shift and go to state 97
    )               reduce using rule 1 (empty -> .)

    print_ayuda                    shift and go to state 99
    empty                          shift and go to state 98

state 68

    (56) funcs -> VOID ID ( ID : type . funcs_ayuda ) [ vars body ] ;
    (58) funcs -> VOID ID ( ID : type . funcs_ayuda ) [ body ] ;
    (62) funcs_ayuda -> . , ID : type funcs_ayuda
    (63) funcs_ayuda -> . empty
    (1) empty -> .

    ,               shift and go to state 101
    )               reduce using rule 1 (empty -> .)

    funcs_ayuda                    shift and go to state 100
    empty                          shift and go to state 102

state 69

    (57) funcs -> VOID ID ( ) [ vars . body ] ;
    (53) body -> . { statements }

    {               shift and go to state 19

    body                           shift and go to state 103

state 70

    (59) funcs -> VOID ID ( ) [ body . ] ;

    ]               shift and go to state 104


state 71

    (5) var_ayuda -> ID var_doble_ayuda : type ; var_ayuda_tail .

    VOID            reduce using rule 5 (var_ayuda -> ID var_doble_ayuda : type ; var_ayuda_tail .)
    MAIN            reduce using rule 5 (var_ayuda -> ID var_doble_ayuda : type ; var_ayuda_tail .)
    {               reduce using rule 5 (var_ayuda -> ID var_doble_ayuda : type ; var_ayuda_tail .)


state 72

    (6) var_ayuda_tail -> var_ayuda .

    VOID            reduce using rule 6 (var_ayuda_tail -> var_ayuda .)
    MAIN            reduce using rule 6 (var_ayuda_tail -> var_ayuda .)
    {               reduce using rule 6 (var_ayuda_tail -> var_ayuda .)


state 73

    (7) var_ayuda_tail -> empty .

    VOID            reduce using rule 7 (var_ayuda_tail -> empty .)
    MAIN            reduce using rule 7 (var_ayuda_tail -> empty .)
    {               reduce using rule 7 (var_ayuda_tail -> empty .)


state 74

    (41) assign -> ID = expression ; .

    }               reduce using rule 41 (assign -> ID = expression ; .)
    ID              reduce using rule 41 (assign -> ID = expression ; .)
    IF              reduce using rule 41 (assign -> ID = expression ; .)
    DO              reduce using rule 41 (assign -> ID = expression ; .)
    PRINT           reduce using rule 41 (assign -> ID = expression ; .)


state 75

    (13) expression -> exp > . exp
    (10) exp -> . exp + termino
    (11) exp -> . exp - termino
    (12) exp -> . termino
    (32) termino -> . termino * factor
    (33) termino -> . termino / factor
    (34) termino -> . factor
    (20) factor -> . ( expression )
    (21) factor -> . ID
    (22) factor -> . cte
    (23) factor -> . + ID
    (24) factor -> . - ID
    (25) factor -> . + cte
    (26) factor -> . - cte
    (54) cte -> . CONST_INT
    (55) cte -> . CONST_FLOAT

    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    exp                            shift and go to state 105
    termino                        shift and go to state 55
    factor                         shift and go to state 57
    cte                            shift and go to state 59

state 76

    (14) expression -> exp < . exp
    (10) exp -> . exp + termino
    (11) exp -> . exp - termino
    (12) exp -> . termino
    (32) termino -> . termino * factor
    (33) termino -> . termino / factor
    (34) termino -> . factor
    (20) factor -> . ( expression )
    (21) factor -> . ID
    (22) factor -> . cte
    (23) factor -> . + ID
    (24) factor -> . - ID
    (25) factor -> . + cte
    (26) factor -> . - cte
    (54) cte -> . CONST_INT
    (55) cte -> . CONST_FLOAT

    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    exp                            shift and go to state 106
    termino                        shift and go to state 55
    factor                         shift and go to state 57
    cte                            shift and go to state 59

state 77

    (15) expression -> exp EQ . exp
    (10) exp -> . exp + termino
    (11) exp -> . exp - termino
    (12) exp -> . termino
    (32) termino -> . termino * factor
    (33) termino -> . termino / factor
    (34) termino -> . factor
    (20) factor -> . ( expression )
    (21) factor -> . ID
    (22) factor -> . cte
    (23) factor -> . + ID
    (24) factor -> . - ID
    (25) factor -> . + cte
    (26) factor -> . - cte
    (54) cte -> . CONST_INT
    (55) cte -> . CONST_FLOAT

    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    exp                            shift and go to state 107
    termino                        shift and go to state 55
    factor                         shift and go to state 57
    cte                            shift and go to state 59

state 78

    (16) expression -> exp GE . exp
    (10) exp -> . exp + termino
    (11) exp -> . exp - termino
    (12) exp -> . termino
    (32) termino -> . termino * factor
    (33) termino -> . termino / factor
    (34) termino -> . factor
    (20) factor -> . ( expression )
    (21) factor -> . ID
    (22) factor -> . cte
    (23) factor -> . + ID
    (24) factor -> . - ID
    (25) factor -> . + cte
    (26) factor -> . - cte
    (54) cte -> . CONST_INT
    (55) cte -> . CONST_FLOAT

    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    exp                            shift and go to state 108
    termino                        shift and go to state 55
    factor                         shift and go to state 57
    cte                            shift and go to state 59

state 79

    (17) expression -> exp LE . exp
    (10) exp -> . exp + termino
    (11) exp -> . exp - termino
    (12) exp -> . termino
    (32) termino -> . termino * factor
    (33) termino -> . termino / factor
    (34) termino -> . factor
    (20) factor -> . ( expression )
    (21) factor -> . ID
    (22) factor -> . cte
    (23) factor -> . + ID
    (24) factor -> . - ID
    (25) factor -> . + cte
    (26) factor -> . - cte
    (54) cte -> . CONST_INT
    (55) cte -> . CONST_FLOAT

    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    exp                            shift and go to state 109
    termino                        shift and go to state 55
    factor                         shift and go to state 57
    cte                            shift and go to state 59

state 80

    (18) expression -> exp NE . exp
    (10) exp -> . exp + termino
    (11) exp -> . exp - termino
    (12) exp -> . termino
    (32) termino -> . termino * factor
    (33) termino -> . termino / factor
    (34) termino -> . factor
    (20) factor -> . ( expression )
    (21) factor -> . ID
    (22) factor -> . cte
    (23) factor -> . + ID
    (24) factor -> . - ID
    (25) factor -> . + cte
    (26) factor -> . - cte
    (54) cte -> . CONST_INT
    (55) cte -> . CONST_FLOAT

    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    exp                            shift and go to state 110
    termino                        shift and go to state 55
    factor                         shift and go to state 57
    cte                            shift and go to state 59

state 81

    (10) exp -> exp + . termino
    (32) termino -> . termino * factor
    (33) termino -> . termino / factor
    (34) termino -> . factor
    (20) factor -> . ( expression )
    (21) factor -> . ID
    (22) factor -> . cte
    (23) factor -> . + ID
    (24) factor -> . - ID
    (25) factor -> . + cte
    (26) factor -> . - cte
    (54) cte -> . CONST_INT
    (55) cte -> . CONST_FLOAT

    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    termino                        shift and go to state 111
    factor                         shift and go to state 57
    cte                            shift and go to state 59

state 82

    (11) exp -> exp - . termino
    (32) termino -> . termino * factor
    (33) termino -> . termino / factor
    (34) termino -> . factor
    (20) factor -> . ( expression )
    (21) factor -> . ID
    (22) factor -> . cte
    (23) factor -> . + ID
    (24) factor -> . - ID
    (25) factor -> . + cte
    (26) factor -> . - cte
    (54) cte -> . CONST_INT
    (55) cte -> . CONST_FLOAT

    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    termino                        shift and go to state 112
    factor                         shift and go to state 57
    cte                            shift and go to state 59

state 83

    (23) factor -> + ID .

    *               reduce using rule 23 (factor -> + ID .)
    /               reduce using rule 23 (factor -> + ID .)
    >               reduce using rule 23 (factor -> + ID .)
    <               reduce using rule 23 (factor -> + ID .)
    EQ              reduce using rule 23 (factor -> + ID .)
    GE              reduce using rule 23 (factor -> + ID .)
    LE              reduce using rule 23 (factor -> + ID .)
    NE              reduce using rule 23 (factor -> + ID .)
    +               reduce using rule 23 (factor -> + ID .)
    -               reduce using rule 23 (factor -> + ID .)
    ;               reduce using rule 23 (factor -> + ID .)
    ,               reduce using rule 23 (factor -> + ID .)
    )               reduce using rule 23 (factor -> + ID .)


state 84

    (25) factor -> + cte .

    *               reduce using rule 25 (factor -> + cte .)
    /               reduce using rule 25 (factor -> + cte .)
    >               reduce using rule 25 (factor -> + cte .)
    <               reduce using rule 25 (factor -> + cte .)
    EQ              reduce using rule 25 (factor -> + cte .)
    GE              reduce using rule 25 (factor -> + cte .)
    LE              reduce using rule 25 (factor -> + cte .)
    NE              reduce using rule 25 (factor -> + cte .)
    +               reduce using rule 25 (factor -> + cte .)
    -               reduce using rule 25 (factor -> + cte .)
    ;               reduce using rule 25 (factor -> + cte .)
    ,               reduce using rule 25 (factor -> + cte .)
    )               reduce using rule 25 (factor -> + cte .)


state 85

    (32) termino -> termino * . factor
    (20) factor -> . ( expression )
    (21) factor -> . ID
    (22) factor -> . cte
    (23) factor -> . + ID
    (24) factor -> . - ID
    (25) factor -> . + cte
    (26) factor -> . - cte
    (54) cte -> . CONST_INT
    (55) cte -> . CONST_FLOAT

    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    factor                         shift and go to state 113
    cte                            shift and go to state 59

state 86

    (33) termino -> termino / . factor
    (20) factor -> . ( expression )
    (21) factor -> . ID
    (22) factor -> . cte
    (23) factor -> . + ID
    (24) factor -> . - ID
    (25) factor -> . + cte
    (26) factor -> . - cte
    (54) cte -> . CONST_INT
    (55) cte -> . CONST_FLOAT

    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    factor                         shift and go to state 114
    cte                            shift and go to state 59

state 87

    (24) factor -> - ID .

    *               reduce using rule 24 (factor -> - ID .)
    /               reduce using rule 24 (factor -> - ID .)
    >               reduce using rule 24 (factor -> - ID .)
    <               reduce using rule 24 (factor -> - ID .)
    EQ              reduce using rule 24 (factor -> - ID .)
    GE              reduce using rule 24 (factor -> - ID .)
    LE              reduce using rule 24 (factor -> - ID .)
    NE              reduce using rule 24 (factor -> - ID .)
    +               reduce using rule 24 (factor -> - ID .)
    -               reduce using rule 24 (factor -> - ID .)
    ;               reduce using rule 24 (factor -> - ID .)
    ,               reduce using rule 24 (factor -> - ID .)
    )               reduce using rule 24 (factor -> - ID .)


state 88

    (26) factor -> - cte .

    *               reduce using rule 26 (factor -> - cte .)
    /               reduce using rule 26 (factor -> - cte .)
    >               reduce using rule 26 (factor -> - cte .)
    <               reduce using rule 26 (factor -> - cte .)
    EQ              reduce using rule 26 (factor -> - cte .)
    GE              reduce using rule 26 (factor -> - cte .)
    LE              reduce using rule 26 (factor -> - cte .)
    NE              reduce using rule 26 (factor -> - cte .)
    +               reduce using rule 26 (factor -> - cte .)
    -               reduce using rule 26 (factor -> - cte .)
    ;               reduce using rule 26 (factor -> - cte .)
    ,               reduce using rule 26 (factor -> - cte .)
    )               reduce using rule 26 (factor -> - cte .)


state 89

    (20) factor -> ( expression . )

    )               shift and go to state 115


state 90

    (42) f_call -> ID ( expression f_call_ayuda . ) ;

    )               shift and go to state 116


state 91

    (44) f_call_ayuda -> , . expression f_call_ayuda
    (13) expression -> . exp > exp
    (14) expression -> . exp < exp
    (15) expression -> . exp EQ exp
    (16) expression -> . exp GE exp
    (17) expression -> . exp LE exp
    (18) expression -> . exp NE exp
    (19) expression -> . exp
    (10) exp -> . exp + termino
    (11) exp -> . exp - termino
    (12) exp -> . termino
    (32) termino -> . termino * factor
    (33) termino -> . termino / factor
    (34) termino -> . factor
    (20) factor -> . ( expression )
    (21) factor -> . ID
    (22) factor -> . cte
    (23) factor -> . + ID
    (24) factor -> . - ID
    (25) factor -> . + cte
    (26) factor -> . - cte
    (54) cte -> . CONST_INT
    (55) cte -> . CONST_FLOAT

    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    expression                     shift and go to state 117
    exp                            shift and go to state 53
    termino                        shift and go to state 55
    factor                         shift and go to state 57
    cte                            shift and go to state 59

state 92

    (45) f_call_ayuda -> empty .

    )               reduce using rule 45 (f_call_ayuda -> empty .)


state 93

    (43) f_call -> ID ( ) ; .

    }               reduce using rule 43 (f_call -> ID ( ) ; .)
    ID              reduce using rule 43 (f_call -> ID ( ) ; .)
    IF              reduce using rule 43 (f_call -> ID ( ) ; .)
    DO              reduce using rule 43 (f_call -> ID ( ) ; .)
    PRINT           reduce using rule 43 (f_call -> ID ( ) ; .)


state 94

    (36) condition -> IF ( expression ) . marcar_if_inicio body ;
    (38) condition -> IF ( expression ) . marcar_if_else_inicio body marcar_else_inicio ELSE body ;
    (37) marcar_if_inicio -> .
    (39) marcar_if_else_inicio -> .

  ! reduce/reduce conflict for { resolved using rule 37 (marcar_if_inicio -> .)
    {               reduce using rule 37 (marcar_if_inicio -> .)

  ! {               [ reduce using rule 39 (marcar_if_else_inicio -> .) ]

    marcar_if_inicio               shift and go to state 118
    marcar_if_else_inicio          shift and go to state 119

state 95

    (35) cycle -> DO body WHILE ( . expression ) ;
    (13) expression -> . exp > exp
    (14) expression -> . exp < exp
    (15) expression -> . exp EQ exp
    (16) expression -> . exp GE exp
    (17) expression -> . exp LE exp
    (18) expression -> . exp NE exp
    (19) expression -> . exp
    (10) exp -> . exp + termino
    (11) exp -> . exp - termino
    (12) exp -> . termino
    (32) termino -> . termino * factor
    (33) termino -> . termino / factor
    (34) termino -> . factor
    (20) factor -> . ( expression )
    (21) factor -> . ID
    (22) factor -> . cte
    (23) factor -> . + ID
    (24) factor -> . - ID
    (25) factor -> . + cte
    (26) factor -> . - cte
    (54) cte -> . CONST_INT
    (55) cte -> . CONST_FLOAT

    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    expression                     shift and go to state 120
    exp                            shift and go to state 53
    termino                        shift and go to state 55
    factor                         shift and go to state 57
    cte                            shift and go to state 59

state 96

    (27) print -> PRINT ( expression print_ayuda . ) ;

    )               shift and go to state 121


state 97

    (29) print_ayuda -> , . expression print_ayuda
    (30) print_ayuda -> , . STRING print_ayuda
    (13) expression -> . exp > exp
    (14) expression -> . exp < exp
    (15) expression -> . exp EQ exp
    (16) expression -> . exp GE exp
    (17) expression -> . exp LE exp
    (18) expression -> . exp NE exp
    (19) expression -> . exp
    (10) exp -> . exp + termino
    (11) exp -> . exp - termino
    (12) exp -> . termino
    (32) termino -> . termino * factor
    (33) termino -> . termino / factor
    (34) termino -> . factor
    (20) factor -> . ( expression )
    (21) factor -> . ID
    (22) factor -> . cte
    (23) factor -> . + ID
    (24) factor -> . - ID
    (25) factor -> . + cte
    (26) factor -> . - cte
    (54) cte -> . CONST_INT
    (55) cte -> . CONST_FLOAT

    STRING          shift and go to state 123
    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    expression                     shift and go to state 122
    exp                            shift and go to state 53
    termino                        shift and go to state 55
    factor                         shift and go to state 57
    cte                            shift and go to state 59

state 98

    (31) print_ayuda -> empty .

    )               reduce using rule 31 (print_ayuda -> empty .)


state 99

    (28) print -> PRINT ( CONST_STRING print_ayuda . ) ;

    )               shift and go to state 124


state 100

    (56) funcs -> VOID ID ( ID : type funcs_ayuda . ) [ vars body ] ;
    (58) funcs -> VOID ID ( ID : type funcs_ayuda . ) [ body ] ;

    )               shift and go to state 125


state 101

    (62) funcs_ayuda -> , . ID : type funcs_ayuda

    ID              shift and go to state 126


state 102

    (63) funcs_ayuda -> empty .

    )               reduce using rule 63 (funcs_ayuda -> empty .)


state 103

    (57) funcs -> VOID ID ( ) [ vars body . ] ;

    ]               shift and go to state 127


state 104

    (59) funcs -> VOID ID ( ) [ body ] . ;

    ;               shift and go to state 128


state 105

    (13) expression -> exp > exp .
    (10) exp -> exp . + termino
    (11) exp -> exp . - termino

    ;               reduce using rule 13 (expression -> exp > exp .)
    ,               reduce using rule 13 (expression -> exp > exp .)
    )               reduce using rule 13 (expression -> exp > exp .)
    +               shift and go to state 81
    -               shift and go to state 82


state 106

    (14) expression -> exp < exp .
    (10) exp -> exp . + termino
    (11) exp -> exp . - termino

    ;               reduce using rule 14 (expression -> exp < exp .)
    ,               reduce using rule 14 (expression -> exp < exp .)
    )               reduce using rule 14 (expression -> exp < exp .)
    +               shift and go to state 81
    -               shift and go to state 82


state 107

    (15) expression -> exp EQ exp .
    (10) exp -> exp . + termino
    (11) exp -> exp . - termino

    ;               reduce using rule 15 (expression -> exp EQ exp .)
    ,               reduce using rule 15 (expression -> exp EQ exp .)
    )               reduce using rule 15 (expression -> exp EQ exp .)
    +               shift and go to state 81
    -               shift and go to state 82


state 108

    (16) expression -> exp GE exp .
    (10) exp -> exp . + termino
    (11) exp -> exp . - termino

    ;               reduce using rule 16 (expression -> exp GE exp .)
    ,               reduce using rule 16 (expression -> exp GE exp .)
    )               reduce using rule 16 (expression -> exp GE exp .)
    +               shift and go to state 81
    -               shift and go to state 82


state 109

    (17) expression -> exp LE exp .
    (10) exp -> exp . + termino
    (11) exp -> exp . - termino

    ;               reduce using rule 17 (expression -> exp LE exp .)
    ,               reduce using rule 17 (expression -> exp LE exp .)
    )               reduce using rule 17 (expression -> exp LE exp .)
    +               shift and go to state 81
    -               shift and go to state 82


state 110

    (18) expression -> exp NE exp .
    (10) exp -> exp . + termino
    (11) exp -> exp . - termino

    ;               reduce using rule 18 (expression -> exp NE exp .)
    ,               reduce using rule 18 (expression -> exp NE exp .)
    )               reduce using rule 18 (expression -> exp NE exp .)
    +               shift and go to state 81
    -               shift and go to state 82


state 111

    (10) exp -> exp + termino .
    (32) termino -> termino . * factor
    (33) termino -> termino . / factor

    >               reduce using rule 10 (exp -> exp + termino .)
    <               reduce using rule 10 (exp -> exp + termino .)
    EQ              reduce using rule 10 (exp -> exp + termino .)
    GE              reduce using rule 10 (exp -> exp + termino .)
    LE              reduce using rule 10 (exp -> exp + termino .)
    NE              reduce using rule 10 (exp -> exp + termino .)
    +               reduce using rule 10 (exp -> exp + termino .)
    -               reduce using rule 10 (exp -> exp + termino .)
    ;               reduce using rule 10 (exp -> exp + termino .)
    ,               reduce using rule 10 (exp -> exp + termino .)
    )               reduce using rule 10 (exp -> exp + termino .)
    *               shift and go to state 85
    /               shift and go to state 86


state 112

    (11) exp -> exp - termino .
    (32) termino -> termino . * factor
    (33) termino -> termino . / factor

    >               reduce using rule 11 (exp -> exp - termino .)
    <               reduce using rule 11 (exp -> exp - termino .)
    EQ              reduce using rule 11 (exp -> exp - termino .)
    GE              reduce using rule 11 (exp -> exp - termino .)
    LE              reduce using rule 11 (exp -> exp - termino .)
    NE              reduce using rule 11 (exp -> exp - termino .)
    +               reduce using rule 11 (exp -> exp - termino .)
    -               reduce using rule 11 (exp -> exp - termino .)
    ;               reduce using rule 11 (exp -> exp - termino .)
    ,               reduce using rule 11 (exp -> exp - termino .)
    )               reduce using rule 11 (exp -> exp - termino .)
    *               shift and go to state 85
    /               shift and go to state 86


state 113

    (32) termino -> termino * factor .

    *               reduce using rule 32 (termino -> termino * factor .)
    /               reduce using rule 32 (termino -> termino * factor .)
    >               reduce using rule 32 (termino -> termino * factor .)
    <               reduce using rule 32 (termino -> termino * factor .)
    EQ              reduce using rule 32 (termino -> termino * factor .)
    GE              reduce using rule 32 (termino -> termino * factor .)
    LE              reduce using rule 32 (termino -> termino * factor .)
    NE              reduce using rule 32 (termino -> termino * factor .)
    +               reduce using rule 32 (termino -> termino * factor .)
    -               reduce using rule 32 (termino -> termino * factor .)
    ;               reduce using rule 32 (termino -> termino * factor .)
    ,               reduce using rule 32 (termino -> termino * factor .)
    )               reduce using rule 32 (termino -> termino * factor .)


state 114

    (33) termino -> termino / factor .

    *               reduce using rule 33 (termino -> termino / factor .)
    /               reduce using rule 33 (termino -> termino / factor .)
    >               reduce using rule 33 (termino -> termino / factor .)
    <               reduce using rule 33 (termino -> termino / factor .)
    EQ              reduce using rule 33 (termino -> termino / factor .)
    GE              reduce using rule 33 (termino -> termino / factor .)
    LE              reduce using rule 33 (termino -> termino / factor .)
    NE              reduce using rule 33 (termino -> termino / factor .)
    +               reduce using rule 33 (termino -> termino / factor .)
    -               reduce using rule 33 (termino -> termino / factor .)
    ;               reduce using rule 33 (termino -> termino / factor .)
    ,               reduce using rule 33 (termino -> termino / factor .)
    )               reduce using rule 33 (termino -> termino / factor .)


state 115

    (20) factor -> ( expression ) .

    *               reduce using rule 20 (factor -> ( expression ) .)
    /               reduce using rule 20 (factor -> ( expression ) .)
    >               reduce using rule 20 (factor -> ( expression ) .)
    <               reduce using rule 20 (factor -> ( expression ) .)
    EQ              reduce using rule 20 (factor -> ( expression ) .)
    GE              reduce using rule 20 (factor -> ( expression ) .)
    LE              reduce using rule 20 (factor -> ( expression ) .)
    NE              reduce using rule 20 (factor -> ( expression ) .)
    +               reduce using rule 20 (factor -> ( expression ) .)
    -               reduce using rule 20 (factor -> ( expression ) .)
    ;               reduce using rule 20 (factor -> ( expression ) .)
    ,               reduce using rule 20 (factor -> ( expression ) .)
    )               reduce using rule 20 (factor -> ( expression ) .)


state 116

    (42) f_call -> ID ( expression f_call_ayuda ) . ;

    ;               shift and go to state 129


state 117

    (44) f_call_ayuda -> , expression . f_call_ayuda
    (44) f_call_ayuda -> . , expression f_call_ayuda
    (45) f_call_ayuda -> . empty
    (1) empty -> .

    ,               shift and go to state 91
    )               reduce using rule 1 (empty -> .)

    f_call_ayuda                   shift and go to state 130
    empty                          shift and go to state 92

state 118

    (36) condition -> IF ( expression ) marcar_if_inicio . body ;
    (53) body -> . { statements }

    {               shift and go to state 19

    body                           shift and go to state 131

state 119

    (38) condition -> IF ( expression ) marcar_if_else_inicio . body marcar_else_inicio ELSE body ;
    (53) body -> . { statements }

    {               shift and go to state 19

    body                           shift and go to state 132

state 120

    (35) cycle -> DO body WHILE ( expression . ) ;

    )               shift and go to state 133


state 121

    (27) print -> PRINT ( expression print_ayuda ) . ;

    ;               shift and go to state 134


state 122

    (29) print_ayuda -> , expression . print_ayuda
    (29) print_ayuda -> . , expression print_ayuda
    (30) print_ayuda -> . , STRING print_ayuda
    (31) print_ayuda -> . empty
    (1) empty -> .

    ,               shift and go to state 97
    )               reduce using rule 1 (empty -> .)

    print_ayuda                    shift and go to state 135
    empty                          shift and go to state 98

state 123

    (30) print_ayuda -> , STRING . print_ayuda
    (29) print_ayuda -> . , expression print_ayuda
    (30) print_ayuda -> . , STRING print_ayuda
    (31) print_ayuda -> . empty
    (1) empty -> .

    ,               shift and go to state 97
    )               reduce using rule 1 (empty -> .)

    print_ayuda                    shift and go to state 136
    empty                          shift and go to state 98

state 124

    (28) print -> PRINT ( CONST_STRING print_ayuda ) . ;

    ;               shift and go to state 137


state 125

    (56) funcs -> VOID ID ( ID : type funcs_ayuda ) . [ vars body ] ;
    (58) funcs -> VOID ID ( ID : type funcs_ayuda ) . [ body ] ;

    [               shift and go to state 138


state 126

    (62) funcs_ayuda -> , ID . : type funcs_ayuda

    :               shift and go to state 139


state 127

    (57) funcs -> VOID ID ( ) [ vars body ] . ;

    ;               shift and go to state 140


state 128

    (59) funcs -> VOID ID ( ) [ body ] ; .

    MAIN            reduce using rule 59 (funcs -> VOID ID ( ) [ body ] ; .)
    VOID            reduce using rule 59 (funcs -> VOID ID ( ) [ body ] ; .)


state 129

    (42) f_call -> ID ( expression f_call_ayuda ) ; .

    }               reduce using rule 42 (f_call -> ID ( expression f_call_ayuda ) ; .)
    ID              reduce using rule 42 (f_call -> ID ( expression f_call_ayuda ) ; .)
    IF              reduce using rule 42 (f_call -> ID ( expression f_call_ayuda ) ; .)
    DO              reduce using rule 42 (f_call -> ID ( expression f_call_ayuda ) ; .)
    PRINT           reduce using rule 42 (f_call -> ID ( expression f_call_ayuda ) ; .)


state 130

    (44) f_call_ayuda -> , expression f_call_ayuda .

    )               reduce using rule 44 (f_call_ayuda -> , expression f_call_ayuda .)


state 131

    (36) condition -> IF ( expression ) marcar_if_inicio body . ;

    ;               shift and go to state 141


state 132

    (38) condition -> IF ( expression ) marcar_if_else_inicio body . marcar_else_inicio ELSE body ;
    (40) marcar_else_inicio -> .

    ELSE            reduce using rule 40 (marcar_else_inicio -> .)

    marcar_else_inicio             shift and go to state 142

state 133

    (35) cycle -> DO body WHILE ( expression ) . ;

    ;               shift and go to state 143


state 134

    (27) print -> PRINT ( expression print_ayuda ) ; .

    }               reduce using rule 27 (print -> PRINT ( expression print_ayuda ) ; .)
    ID              reduce using rule 27 (print -> PRINT ( expression print_ayuda ) ; .)
    IF              reduce using rule 27 (print -> PRINT ( expression print_ayuda ) ; .)
    DO              reduce using rule 27 (print -> PRINT ( expression print_ayuda ) ; .)
    PRINT           reduce using rule 27 (print -> PRINT ( expression print_ayuda ) ; .)


state 135

    (29) print_ayuda -> , expression print_ayuda .

    )               reduce using rule 29 (print_ayuda -> , expression print_ayuda .)


state 136

    (30) print_ayuda -> , STRING print_ayuda .

    )               reduce using rule 30 (print_ayuda -> , STRING print_ayuda .)


state 137

    (28) print -> PRINT ( CONST_STRING print_ayuda ) ; .

    }               reduce using rule 28 (print -> PRINT ( CONST_STRING print_ayuda ) ; .)
    ID              reduce using rule 28 (print -> PRINT ( CONST_STRING print_ayuda ) ; .)
    IF              reduce using rule 28 (print -> PRINT ( CONST_STRING print_ayuda ) ; .)
    DO              reduce using rule 28 (print -> PRINT ( CONST_STRING print_ayuda ) ; .)
    PRINT           reduce using rule 28 (print -> PRINT ( CONST_STRING print_ayuda ) ; .)


state 138

    (56) funcs -> VOID ID ( ID : type funcs_ayuda ) [ . vars body ] ;
    (58) funcs -> VOID ID ( ID : type funcs_ayuda ) [ . body ] ;
    (4) vars -> . VAR var_ayuda
    (53) body -> . { statements }

    VAR             shift and go to state 6
    {               shift and go to state 19

    vars                           shift and go to state 144
    body                           shift and go to state 145

state 139

    (62) funcs_ayuda -> , ID : . type funcs_ayuda
    (2) type -> . INT
    (3) type -> . FLOAT

    INT             shift and go to state 38
    FLOAT           shift and go to state 39

    type                           shift and go to state 146

state 140

    (57) funcs -> VOID ID ( ) [ vars body ] ; .

    MAIN            reduce using rule 57 (funcs -> VOID ID ( ) [ vars body ] ; .)
    VOID            reduce using rule 57 (funcs -> VOID ID ( ) [ vars body ] ; .)


state 141

    (36) condition -> IF ( expression ) marcar_if_inicio body ; .

    }               reduce using rule 36 (condition -> IF ( expression ) marcar_if_inicio body ; .)
    ID              reduce using rule 36 (condition -> IF ( expression ) marcar_if_inicio body ; .)
    IF              reduce using rule 36 (condition -> IF ( expression ) marcar_if_inicio body ; .)
    DO              reduce using rule 36 (condition -> IF ( expression ) marcar_if_inicio body ; .)
    PRINT           reduce using rule 36 (condition -> IF ( expression ) marcar_if_inicio body ; .)


state 142

    (38) condition -> IF ( expression ) marcar_if_else_inicio body marcar_else_inicio . ELSE body ;

    ELSE            shift and go to state 147


state 143

    (35) cycle -> DO body WHILE ( expression ) ; .

    }               reduce using rule 35 (cycle -> DO body WHILE ( expression ) ; .)
    ID              reduce using rule 35 (cycle -> DO body WHILE ( expression ) ; .)
    IF              reduce using rule 35 (cycle -> DO body WHILE ( expression ) ; .)
    DO              reduce using rule 35 (cycle -> DO body WHILE ( expression ) ; .)
    PRINT           reduce using rule 35 (cycle -> DO body WHILE ( expression ) ; .)


state 144

    (56) funcs -> VOID ID ( ID : type funcs_ayuda ) [ vars . body ] ;
    (53) body -> . { statements }

    {               shift and go to state 19

    body                           shift and go to state 148

state 145

    (58) funcs -> VOID ID ( ID : type funcs_ayuda ) [ body . ] ;

    ]               shift and go to state 149


state 146

    (62) funcs_ayuda -> , ID : type . funcs_ayuda
    (62) funcs_ayuda -> . , ID : type funcs_ayuda
    (63) funcs_ayuda -> . empty
    (1) empty -> .

    ,               shift and go to state 101
    )               reduce using rule 1 (empty -> .)

    funcs_ayuda                    shift and go to state 150
    empty                          shift and go to state 102

state 147

    (38) condition -> IF ( expression ) marcar_if_else_inicio body marcar_else_inicio ELSE . body ;
    (53) body -> . { statements }

    {               shift and go to state 19

    body                           shift and go to state 151

state 148

    (56) funcs -> VOID ID ( ID : type funcs_ayuda ) [ vars body . ] ;

    ]               shift and go to state 152


state 149

    (58) funcs -> VOID ID ( ID : type funcs_ayuda ) [ body ] . ;

    ;               shift and go to state 153


state 150

    (62) funcs_ayuda -> , ID : type funcs_ayuda .

    )               reduce using rule 62 (funcs_ayuda -> , ID : type funcs_ayuda .)


state 151

    (38) condition -> IF ( expression ) marcar_if_else_inicio body marcar_else_inicio ELSE body . ;

    ;               shift and go to state 154


state 152

    (56) funcs -> VOID ID ( ID : type funcs_ayuda ) [ vars body ] . ;

    ;               shift and go to state 155


state 153

    (58) funcs -> VOID ID ( ID : type funcs_ayuda ) [ body ] ; .

    MAIN            reduce using rule 58 (funcs -> VOID ID ( ID : type funcs_ayuda ) [ body ] ; .)
    VOID            reduce using rule 58 (funcs -> VOID ID ( ID : type funcs_ayuda ) [ body ] ; .)


state 154

    (38) condition -> IF ( expression ) marcar_if_else_inicio body marcar_else_inicio ELSE body ; .

    }               reduce using rule 38 (condition -> IF ( expression ) marcar_if_else_inicio body marcar_else_inicio ELSE body ; .)
    ID              reduce using rule 38 (condition -> IF ( expression ) marcar_if_else_inicio body marcar_else_inicio ELSE body ; .)
    IF              reduce using rule 38 (condition -> IF ( expression ) marcar_if_else_inicio body marcar_else_inicio ELSE body ; .)
    DO              reduce using rule 38 (condition -> IF ( expression ) marcar_if_else_inicio body marcar_else_inicio ELSE body ; .)
    PRINT           reduce using rule 38 (condition -> IF ( expression ) marcar_if_else_inicio body marcar_else_inicio ELSE body ; .)


state 155

    (56) funcs -> VOID ID ( ID : type funcs_ayuda ) [ vars body ] ; .

    MAIN            reduce using rule 56 (funcs -> VOID ID ( ID : type funcs_ayuda ) [ vars body ] ; .)
    VOID            reduce using rule 56 (funcs -> VOID ID ( ID : type funcs_ayuda ) [ vars body ] ; .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for VOID in state 5 resolved as shift
WARNING: shift/reduce conflict for VOID in state 7 resolved as shift
WARNING: shift/reduce conflict for MAIN in state 7 resolved as shift
WARNING: shift/reduce conflict for VOID in state 12 resolved as shift
WARNING: shift/reduce conflict for VOID in state 12 resolved as shift
WARNING: reduce/reduce conflict in state 12 resolved using rule (empty -> <empty>)
WARNING: rejected rule (funcs -> funcs funcs) in state 12
WARNING: reduce/reduce conflict in state 94 resolved using rule (marcar_if_inicio -> <empty>)
WARNING: rejected rule (marcar_if_else_inicio -> <empty>) in state 94
WARNING: Rule (funcs -> funcs funcs) is never reduced
WARNING: Rule (marcar_if_else_inicio -> <empty>) is never reduced
