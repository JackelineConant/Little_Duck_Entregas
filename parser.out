Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    FOR
    THEN

Grammar

Rule 0     S' -> program
Rule 1     empty -> <empty>
Rule 2     type -> INT
Rule 3     type -> FLOAT
Rule 4     vars -> VAR var_ayuda
Rule 5     var_ayuda -> ID var_doble_ayuda : type ; var_ayuda_tail
Rule 6     var_ayuda_tail -> var_ayuda
Rule 7     var_ayuda_tail -> empty
Rule 8     var_doble_ayuda -> , ID var_doble_ayuda
Rule 9     var_doble_ayuda -> empty
Rule 10    exp -> exp + termino
Rule 11    exp -> exp - termino
Rule 12    exp -> termino
Rule 13    expression -> exp > exp
Rule 14    expression -> exp < exp
Rule 15    expression -> exp EQ exp
Rule 16    expression -> exp GE exp
Rule 17    expression -> exp LE exp
Rule 18    expression -> exp NE exp
Rule 19    expression -> exp
Rule 20    factor -> ( expression )
Rule 21    factor -> ID
Rule 22    factor -> cte
Rule 23    factor -> + ID
Rule 24    factor -> - ID
Rule 25    factor -> + cte
Rule 26    factor -> - cte
Rule 27    print -> PRINT ( expression print_ayuda ) ;
Rule 28    print -> PRINT ( CONST_STRING print_ayuda ) ;
Rule 29    print_ayuda -> , expression print_ayuda
Rule 30    print_ayuda -> , STRING print_ayuda
Rule 31    print_ayuda -> empty
Rule 32    termino -> termino * factor
Rule 33    termino -> termino / factor
Rule 34    termino -> factor
Rule 35    cycle -> DO body WHILE ( expression ) ;
Rule 36    condition -> IF ( expression ) body ;
Rule 37    condition -> IF ( expression ) body ELSE body ;
Rule 38    assign -> ID = expression ;
Rule 39    f_call -> ID ( expression f_call_ayuda ) ;
Rule 40    f_call -> ID ( ) ;
Rule 41    f_call_ayuda -> , expression f_call_ayuda
Rule 42    f_call_ayuda -> empty
Rule 43    statements -> statements statement
Rule 44    statements -> statement
Rule 45    statement -> assign
Rule 46    statement -> condition
Rule 47    statement -> cycle
Rule 48    statement -> f_call
Rule 49    statement -> print
Rule 50    body -> { statements }
Rule 51    cte -> CONST_INT
Rule 52    cte -> CONST_FLOAT
Rule 53    funcs -> VOID ID ( ID : type funcs_ayuda ) [ vars body ] ;
Rule 54    funcs -> VOID ID ( ) [ vars body ] ;
Rule 55    funcs -> VOID ID ( ID : type funcs_ayuda ) [ body ] ;
Rule 56    funcs -> VOID ID ( ) [ body ] ;
Rule 57    funcs -> funcs funcs
Rule 58    funcs -> empty
Rule 59    funcs_ayuda -> , ID : type funcs_ayuda
Rule 60    funcs_ayuda -> empty
Rule 61    program -> PROGRAM ID ; vars funcs MAIN body END

Terminals, with rules where they appear

(                    : 20 27 28 35 36 37 39 40 53 54 55 56
)                    : 20 27 28 35 36 37 39 40 53 54 55 56
*                    : 32
+                    : 10 23 25
,                    : 8 29 30 41 59
-                    : 11 24 26
/                    : 33
:                    : 5 53 55 59
;                    : 5 27 28 35 36 37 38 39 40 53 54 55 56 61
<                    : 14
=                    : 38
>                    : 13
CONST_FLOAT          : 52
CONST_INT            : 51
CONST_STRING         : 28
DO                   : 35
ELSE                 : 37
END                  : 61
EQ                   : 15
FLOAT                : 3
FOR                  : 
GE                   : 16
ID                   : 5 8 21 23 24 38 39 40 53 53 54 55 55 56 59 61
IF                   : 36 37
INT                  : 2
LE                   : 17
MAIN                 : 61
NE                   : 18
PRINT                : 27 28
PROGRAM              : 61
STRING               : 30
THEN                 : 
VAR                  : 4
VOID                 : 53 54 55 56
WHILE                : 35
[                    : 53 54 55 56
]                    : 53 54 55 56
error                : 
{                    : 50
}                    : 50

Nonterminals, with rules where they appear

assign               : 45
body                 : 35 36 37 37 53 54 55 56 61
condition            : 46
cte                  : 22 25 26
cycle                : 47
empty                : 7 9 31 42 58 60
exp                  : 10 11 13 13 14 14 15 15 16 16 17 17 18 18 19
expression           : 20 27 29 35 36 37 38 39 41
f_call               : 48
f_call_ayuda         : 39 41
factor               : 32 33 34
funcs                : 57 57 61
funcs_ayuda          : 53 55 59
print                : 49
print_ayuda          : 27 28 29 30
program              : 0
statement            : 43 44
statements           : 43 50
termino              : 10 11 12 32 33
type                 : 5 53 55 59
var_ayuda            : 4 6
var_ayuda_tail       : 5
var_doble_ayuda      : 5 8
vars                 : 53 54 61

Parsing method: LALR

state 0

    (0) S' -> . program
    (61) program -> . PROGRAM ID ; vars funcs MAIN body END

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (61) program -> PROGRAM . ID ; vars funcs MAIN body END

    ID              shift and go to state 3


state 3

    (61) program -> PROGRAM ID . ; vars funcs MAIN body END

    ;               shift and go to state 4


state 4

    (61) program -> PROGRAM ID ; . vars funcs MAIN body END
    (4) vars -> . VAR var_ayuda

    VAR             shift and go to state 6

    vars                           shift and go to state 5

state 5

    (61) program -> PROGRAM ID ; vars . funcs MAIN body END
    (53) funcs -> . VOID ID ( ID : type funcs_ayuda ) [ vars body ] ;
    (54) funcs -> . VOID ID ( ) [ vars body ] ;
    (55) funcs -> . VOID ID ( ID : type funcs_ayuda ) [ body ] ;
    (56) funcs -> . VOID ID ( ) [ body ] ;
    (57) funcs -> . funcs funcs
    (58) funcs -> . empty
    (1) empty -> .

  ! shift/reduce conflict for VOID resolved as shift
    VOID            shift and go to state 8
    MAIN            reduce using rule 1 (empty -> .)

  ! VOID            [ reduce using rule 1 (empty -> .) ]

    funcs                          shift and go to state 7
    empty                          shift and go to state 9

state 6

    (4) vars -> VAR . var_ayuda
    (5) var_ayuda -> . ID var_doble_ayuda : type ; var_ayuda_tail

    ID              shift and go to state 11

    var_ayuda                      shift and go to state 10

state 7

    (61) program -> PROGRAM ID ; vars funcs . MAIN body END
    (57) funcs -> funcs . funcs
    (53) funcs -> . VOID ID ( ID : type funcs_ayuda ) [ vars body ] ;
    (54) funcs -> . VOID ID ( ) [ vars body ] ;
    (55) funcs -> . VOID ID ( ID : type funcs_ayuda ) [ body ] ;
    (56) funcs -> . VOID ID ( ) [ body ] ;
    (57) funcs -> . funcs funcs
    (58) funcs -> . empty
    (1) empty -> .

  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for MAIN resolved as shift
    MAIN            shift and go to state 13
    VOID            shift and go to state 8

  ! VOID            [ reduce using rule 1 (empty -> .) ]
  ! MAIN            [ reduce using rule 1 (empty -> .) ]

    funcs                          shift and go to state 12
    empty                          shift and go to state 9

state 8

    (53) funcs -> VOID . ID ( ID : type funcs_ayuda ) [ vars body ] ;
    (54) funcs -> VOID . ID ( ) [ vars body ] ;
    (55) funcs -> VOID . ID ( ID : type funcs_ayuda ) [ body ] ;
    (56) funcs -> VOID . ID ( ) [ body ] ;

    ID              shift and go to state 14


state 9

    (58) funcs -> empty .

    MAIN            reduce using rule 58 (funcs -> empty .)
    VOID            reduce using rule 58 (funcs -> empty .)


state 10

    (4) vars -> VAR var_ayuda .

    VOID            reduce using rule 4 (vars -> VAR var_ayuda .)
    MAIN            reduce using rule 4 (vars -> VAR var_ayuda .)
    {               reduce using rule 4 (vars -> VAR var_ayuda .)


state 11

    (5) var_ayuda -> ID . var_doble_ayuda : type ; var_ayuda_tail
    (8) var_doble_ayuda -> . , ID var_doble_ayuda
    (9) var_doble_ayuda -> . empty
    (1) empty -> .

    ,               shift and go to state 16
    :               reduce using rule 1 (empty -> .)

    var_doble_ayuda                shift and go to state 15
    empty                          shift and go to state 17

state 12

    (57) funcs -> funcs funcs .
    (57) funcs -> funcs . funcs
    (53) funcs -> . VOID ID ( ID : type funcs_ayuda ) [ vars body ] ;
    (54) funcs -> . VOID ID ( ) [ vars body ] ;
    (55) funcs -> . VOID ID ( ID : type funcs_ayuda ) [ body ] ;
    (56) funcs -> . VOID ID ( ) [ body ] ;
    (57) funcs -> . funcs funcs
    (58) funcs -> . empty
    (1) empty -> .

  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! reduce/reduce conflict for MAIN resolved using rule 1 (empty -> .)
    VOID            shift and go to state 8
    MAIN            reduce using rule 1 (empty -> .)

  ! MAIN            [ reduce using rule 57 (funcs -> funcs funcs .) ]
  ! VOID            [ reduce using rule 57 (funcs -> funcs funcs .) ]
  ! VOID            [ reduce using rule 1 (empty -> .) ]

    funcs                          shift and go to state 12
    empty                          shift and go to state 9

state 13

    (61) program -> PROGRAM ID ; vars funcs MAIN . body END
    (50) body -> . { statements }

    {               shift and go to state 19

    body                           shift and go to state 18

state 14

    (53) funcs -> VOID ID . ( ID : type funcs_ayuda ) [ vars body ] ;
    (54) funcs -> VOID ID . ( ) [ vars body ] ;
    (55) funcs -> VOID ID . ( ID : type funcs_ayuda ) [ body ] ;
    (56) funcs -> VOID ID . ( ) [ body ] ;

    (               shift and go to state 20


state 15

    (5) var_ayuda -> ID var_doble_ayuda . : type ; var_ayuda_tail

    :               shift and go to state 21


state 16

    (8) var_doble_ayuda -> , . ID var_doble_ayuda

    ID              shift and go to state 22


state 17

    (9) var_doble_ayuda -> empty .

    :               reduce using rule 9 (var_doble_ayuda -> empty .)


state 18

    (61) program -> PROGRAM ID ; vars funcs MAIN body . END

    END             shift and go to state 23


state 19

    (50) body -> { . statements }
    (43) statements -> . statements statement
    (44) statements -> . statement
    (45) statement -> . assign
    (46) statement -> . condition
    (47) statement -> . cycle
    (48) statement -> . f_call
    (49) statement -> . print
    (38) assign -> . ID = expression ;
    (36) condition -> . IF ( expression ) body ;
    (37) condition -> . IF ( expression ) body ELSE body ;
    (35) cycle -> . DO body WHILE ( expression ) ;
    (39) f_call -> . ID ( expression f_call_ayuda ) ;
    (40) f_call -> . ID ( ) ;
    (27) print -> . PRINT ( expression print_ayuda ) ;
    (28) print -> . PRINT ( CONST_STRING print_ayuda ) ;

    ID              shift and go to state 31
    IF              shift and go to state 32
    DO              shift and go to state 33
    PRINT           shift and go to state 34

    statements                     shift and go to state 24
    statement                      shift and go to state 25
    assign                         shift and go to state 26
    condition                      shift and go to state 27
    cycle                          shift and go to state 28
    f_call                         shift and go to state 29
    print                          shift and go to state 30

state 20

    (53) funcs -> VOID ID ( . ID : type funcs_ayuda ) [ vars body ] ;
    (54) funcs -> VOID ID ( . ) [ vars body ] ;
    (55) funcs -> VOID ID ( . ID : type funcs_ayuda ) [ body ] ;
    (56) funcs -> VOID ID ( . ) [ body ] ;

    ID              shift and go to state 35
    )               shift and go to state 36


state 21

    (5) var_ayuda -> ID var_doble_ayuda : . type ; var_ayuda_tail
    (2) type -> . INT
    (3) type -> . FLOAT

    INT             shift and go to state 38
    FLOAT           shift and go to state 39

    type                           shift and go to state 37

state 22

    (8) var_doble_ayuda -> , ID . var_doble_ayuda
    (8) var_doble_ayuda -> . , ID var_doble_ayuda
    (9) var_doble_ayuda -> . empty
    (1) empty -> .

    ,               shift and go to state 16
    :               reduce using rule 1 (empty -> .)

    var_doble_ayuda                shift and go to state 40
    empty                          shift and go to state 17

state 23

    (61) program -> PROGRAM ID ; vars funcs MAIN body END .

    $end            reduce using rule 61 (program -> PROGRAM ID ; vars funcs MAIN body END .)


state 24

    (50) body -> { statements . }
    (43) statements -> statements . statement
    (45) statement -> . assign
    (46) statement -> . condition
    (47) statement -> . cycle
    (48) statement -> . f_call
    (49) statement -> . print
    (38) assign -> . ID = expression ;
    (36) condition -> . IF ( expression ) body ;
    (37) condition -> . IF ( expression ) body ELSE body ;
    (35) cycle -> . DO body WHILE ( expression ) ;
    (39) f_call -> . ID ( expression f_call_ayuda ) ;
    (40) f_call -> . ID ( ) ;
    (27) print -> . PRINT ( expression print_ayuda ) ;
    (28) print -> . PRINT ( CONST_STRING print_ayuda ) ;

    }               shift and go to state 41
    ID              shift and go to state 31
    IF              shift and go to state 32
    DO              shift and go to state 33
    PRINT           shift and go to state 34

    statement                      shift and go to state 42
    assign                         shift and go to state 26
    condition                      shift and go to state 27
    cycle                          shift and go to state 28
    f_call                         shift and go to state 29
    print                          shift and go to state 30

state 25

    (44) statements -> statement .

    }               reduce using rule 44 (statements -> statement .)
    ID              reduce using rule 44 (statements -> statement .)
    IF              reduce using rule 44 (statements -> statement .)
    DO              reduce using rule 44 (statements -> statement .)
    PRINT           reduce using rule 44 (statements -> statement .)


state 26

    (45) statement -> assign .

    }               reduce using rule 45 (statement -> assign .)
    ID              reduce using rule 45 (statement -> assign .)
    IF              reduce using rule 45 (statement -> assign .)
    DO              reduce using rule 45 (statement -> assign .)
    PRINT           reduce using rule 45 (statement -> assign .)


state 27

    (46) statement -> condition .

    }               reduce using rule 46 (statement -> condition .)
    ID              reduce using rule 46 (statement -> condition .)
    IF              reduce using rule 46 (statement -> condition .)
    DO              reduce using rule 46 (statement -> condition .)
    PRINT           reduce using rule 46 (statement -> condition .)


state 28

    (47) statement -> cycle .

    }               reduce using rule 47 (statement -> cycle .)
    ID              reduce using rule 47 (statement -> cycle .)
    IF              reduce using rule 47 (statement -> cycle .)
    DO              reduce using rule 47 (statement -> cycle .)
    PRINT           reduce using rule 47 (statement -> cycle .)


state 29

    (48) statement -> f_call .

    }               reduce using rule 48 (statement -> f_call .)
    ID              reduce using rule 48 (statement -> f_call .)
    IF              reduce using rule 48 (statement -> f_call .)
    DO              reduce using rule 48 (statement -> f_call .)
    PRINT           reduce using rule 48 (statement -> f_call .)


state 30

    (49) statement -> print .

    }               reduce using rule 49 (statement -> print .)
    ID              reduce using rule 49 (statement -> print .)
    IF              reduce using rule 49 (statement -> print .)
    DO              reduce using rule 49 (statement -> print .)
    PRINT           reduce using rule 49 (statement -> print .)


state 31

    (38) assign -> ID . = expression ;
    (39) f_call -> ID . ( expression f_call_ayuda ) ;
    (40) f_call -> ID . ( ) ;

    =               shift and go to state 43
    (               shift and go to state 44


state 32

    (36) condition -> IF . ( expression ) body ;
    (37) condition -> IF . ( expression ) body ELSE body ;

    (               shift and go to state 45


state 33

    (35) cycle -> DO . body WHILE ( expression ) ;
    (50) body -> . { statements }

    {               shift and go to state 19

    body                           shift and go to state 46

state 34

    (27) print -> PRINT . ( expression print_ayuda ) ;
    (28) print -> PRINT . ( CONST_STRING print_ayuda ) ;

    (               shift and go to state 47


state 35

    (53) funcs -> VOID ID ( ID . : type funcs_ayuda ) [ vars body ] ;
    (55) funcs -> VOID ID ( ID . : type funcs_ayuda ) [ body ] ;

    :               shift and go to state 48


state 36

    (54) funcs -> VOID ID ( ) . [ vars body ] ;
    (56) funcs -> VOID ID ( ) . [ body ] ;

    [               shift and go to state 49


state 37

    (5) var_ayuda -> ID var_doble_ayuda : type . ; var_ayuda_tail

    ;               shift and go to state 50


state 38

    (2) type -> INT .

    ;               reduce using rule 2 (type -> INT .)
    ,               reduce using rule 2 (type -> INT .)
    )               reduce using rule 2 (type -> INT .)


state 39

    (3) type -> FLOAT .

    ;               reduce using rule 3 (type -> FLOAT .)
    ,               reduce using rule 3 (type -> FLOAT .)
    )               reduce using rule 3 (type -> FLOAT .)


state 40

    (8) var_doble_ayuda -> , ID var_doble_ayuda .

    :               reduce using rule 8 (var_doble_ayuda -> , ID var_doble_ayuda .)


state 41

    (50) body -> { statements } .

    END             reduce using rule 50 (body -> { statements } .)
    WHILE           reduce using rule 50 (body -> { statements } .)
    ]               reduce using rule 50 (body -> { statements } .)
    ;               reduce using rule 50 (body -> { statements } .)
    ELSE            reduce using rule 50 (body -> { statements } .)


state 42

    (43) statements -> statements statement .

    }               reduce using rule 43 (statements -> statements statement .)
    ID              reduce using rule 43 (statements -> statements statement .)
    IF              reduce using rule 43 (statements -> statements statement .)
    DO              reduce using rule 43 (statements -> statements statement .)
    PRINT           reduce using rule 43 (statements -> statements statement .)


state 43

    (38) assign -> ID = . expression ;
    (13) expression -> . exp > exp
    (14) expression -> . exp < exp
    (15) expression -> . exp EQ exp
    (16) expression -> . exp GE exp
    (17) expression -> . exp LE exp
    (18) expression -> . exp NE exp
    (19) expression -> . exp
    (10) exp -> . exp + termino
    (11) exp -> . exp - termino
    (12) exp -> . termino
    (32) termino -> . termino * factor
    (33) termino -> . termino / factor
    (34) termino -> . factor
    (20) factor -> . ( expression )
    (21) factor -> . ID
    (22) factor -> . cte
    (23) factor -> . + ID
    (24) factor -> . - ID
    (25) factor -> . + cte
    (26) factor -> . - cte
    (51) cte -> . CONST_INT
    (52) cte -> . CONST_FLOAT

    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    expression                     shift and go to state 52
    exp                            shift and go to state 53
    termino                        shift and go to state 55
    factor                         shift and go to state 57
    cte                            shift and go to state 59

state 44

    (39) f_call -> ID ( . expression f_call_ayuda ) ;
    (40) f_call -> ID ( . ) ;
    (13) expression -> . exp > exp
    (14) expression -> . exp < exp
    (15) expression -> . exp EQ exp
    (16) expression -> . exp GE exp
    (17) expression -> . exp LE exp
    (18) expression -> . exp NE exp
    (19) expression -> . exp
    (10) exp -> . exp + termino
    (11) exp -> . exp - termino
    (12) exp -> . termino
    (32) termino -> . termino * factor
    (33) termino -> . termino / factor
    (34) termino -> . factor
    (20) factor -> . ( expression )
    (21) factor -> . ID
    (22) factor -> . cte
    (23) factor -> . + ID
    (24) factor -> . - ID
    (25) factor -> . + cte
    (26) factor -> . - cte
    (51) cte -> . CONST_INT
    (52) cte -> . CONST_FLOAT

    )               shift and go to state 63
    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    expression                     shift and go to state 62
    exp                            shift and go to state 53
    termino                        shift and go to state 55
    factor                         shift and go to state 57
    cte                            shift and go to state 59

state 45

    (36) condition -> IF ( . expression ) body ;
    (37) condition -> IF ( . expression ) body ELSE body ;
    (13) expression -> . exp > exp
    (14) expression -> . exp < exp
    (15) expression -> . exp EQ exp
    (16) expression -> . exp GE exp
    (17) expression -> . exp LE exp
    (18) expression -> . exp NE exp
    (19) expression -> . exp
    (10) exp -> . exp + termino
    (11) exp -> . exp - termino
    (12) exp -> . termino
    (32) termino -> . termino * factor
    (33) termino -> . termino / factor
    (34) termino -> . factor
    (20) factor -> . ( expression )
    (21) factor -> . ID
    (22) factor -> . cte
    (23) factor -> . + ID
    (24) factor -> . - ID
    (25) factor -> . + cte
    (26) factor -> . - cte
    (51) cte -> . CONST_INT
    (52) cte -> . CONST_FLOAT

    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    expression                     shift and go to state 64
    exp                            shift and go to state 53
    termino                        shift and go to state 55
    factor                         shift and go to state 57
    cte                            shift and go to state 59

state 46

    (35) cycle -> DO body . WHILE ( expression ) ;

    WHILE           shift and go to state 65


state 47

    (27) print -> PRINT ( . expression print_ayuda ) ;
    (28) print -> PRINT ( . CONST_STRING print_ayuda ) ;
    (13) expression -> . exp > exp
    (14) expression -> . exp < exp
    (15) expression -> . exp EQ exp
    (16) expression -> . exp GE exp
    (17) expression -> . exp LE exp
    (18) expression -> . exp NE exp
    (19) expression -> . exp
    (10) exp -> . exp + termino
    (11) exp -> . exp - termino
    (12) exp -> . termino
    (32) termino -> . termino * factor
    (33) termino -> . termino / factor
    (34) termino -> . factor
    (20) factor -> . ( expression )
    (21) factor -> . ID
    (22) factor -> . cte
    (23) factor -> . + ID
    (24) factor -> . - ID
    (25) factor -> . + cte
    (26) factor -> . - cte
    (51) cte -> . CONST_INT
    (52) cte -> . CONST_FLOAT

    CONST_STRING    shift and go to state 67
    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    expression                     shift and go to state 66
    exp                            shift and go to state 53
    termino                        shift and go to state 55
    factor                         shift and go to state 57
    cte                            shift and go to state 59

state 48

    (53) funcs -> VOID ID ( ID : . type funcs_ayuda ) [ vars body ] ;
    (55) funcs -> VOID ID ( ID : . type funcs_ayuda ) [ body ] ;
    (2) type -> . INT
    (3) type -> . FLOAT

    INT             shift and go to state 38
    FLOAT           shift and go to state 39

    type                           shift and go to state 68

state 49

    (54) funcs -> VOID ID ( ) [ . vars body ] ;
    (56) funcs -> VOID ID ( ) [ . body ] ;
    (4) vars -> . VAR var_ayuda
    (50) body -> . { statements }

    VAR             shift and go to state 6
    {               shift and go to state 19

    vars                           shift and go to state 69
    body                           shift and go to state 70

state 50

    (5) var_ayuda -> ID var_doble_ayuda : type ; . var_ayuda_tail
    (6) var_ayuda_tail -> . var_ayuda
    (7) var_ayuda_tail -> . empty
    (5) var_ayuda -> . ID var_doble_ayuda : type ; var_ayuda_tail
    (1) empty -> .

    ID              shift and go to state 11
    VOID            reduce using rule 1 (empty -> .)
    MAIN            reduce using rule 1 (empty -> .)
    {               reduce using rule 1 (empty -> .)

    var_ayuda_tail                 shift and go to state 71
    var_ayuda                      shift and go to state 72
    empty                          shift and go to state 73

state 51

    (21) factor -> ID .

    *               reduce using rule 21 (factor -> ID .)
    /               reduce using rule 21 (factor -> ID .)
    >               reduce using rule 21 (factor -> ID .)
    <               reduce using rule 21 (factor -> ID .)
    EQ              reduce using rule 21 (factor -> ID .)
    GE              reduce using rule 21 (factor -> ID .)
    LE              reduce using rule 21 (factor -> ID .)
    NE              reduce using rule 21 (factor -> ID .)
    +               reduce using rule 21 (factor -> ID .)
    -               reduce using rule 21 (factor -> ID .)
    ;               reduce using rule 21 (factor -> ID .)
    ,               reduce using rule 21 (factor -> ID .)
    )               reduce using rule 21 (factor -> ID .)


state 52

    (38) assign -> ID = expression . ;

    ;               shift and go to state 74


state 53

    (13) expression -> exp . > exp
    (14) expression -> exp . < exp
    (15) expression -> exp . EQ exp
    (16) expression -> exp . GE exp
    (17) expression -> exp . LE exp
    (18) expression -> exp . NE exp
    (19) expression -> exp .
    (10) exp -> exp . + termino
    (11) exp -> exp . - termino

    >               shift and go to state 75
    <               shift and go to state 76
    EQ              shift and go to state 77
    GE              shift and go to state 78
    LE              shift and go to state 79
    NE              shift and go to state 80
    ;               reduce using rule 19 (expression -> exp .)
    ,               reduce using rule 19 (expression -> exp .)
    )               reduce using rule 19 (expression -> exp .)
    +               shift and go to state 81
    -               shift and go to state 82


state 54

    (23) factor -> + . ID
    (25) factor -> + . cte
    (51) cte -> . CONST_INT
    (52) cte -> . CONST_FLOAT

    ID              shift and go to state 83
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    cte                            shift and go to state 84

state 55

    (12) exp -> termino .
    (32) termino -> termino . * factor
    (33) termino -> termino . / factor

    >               reduce using rule 12 (exp -> termino .)
    <               reduce using rule 12 (exp -> termino .)
    EQ              reduce using rule 12 (exp -> termino .)
    GE              reduce using rule 12 (exp -> termino .)
    LE              reduce using rule 12 (exp -> termino .)
    NE              reduce using rule 12 (exp -> termino .)
    +               reduce using rule 12 (exp -> termino .)
    -               reduce using rule 12 (exp -> termino .)
    ;               reduce using rule 12 (exp -> termino .)
    ,               reduce using rule 12 (exp -> termino .)
    )               reduce using rule 12 (exp -> termino .)
    *               shift and go to state 85
    /               shift and go to state 86


state 56

    (24) factor -> - . ID
    (26) factor -> - . cte
    (51) cte -> . CONST_INT
    (52) cte -> . CONST_FLOAT

    ID              shift and go to state 87
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    cte                            shift and go to state 88

state 57

    (34) termino -> factor .

    *               reduce using rule 34 (termino -> factor .)
    /               reduce using rule 34 (termino -> factor .)
    >               reduce using rule 34 (termino -> factor .)
    <               reduce using rule 34 (termino -> factor .)
    EQ              reduce using rule 34 (termino -> factor .)
    GE              reduce using rule 34 (termino -> factor .)
    LE              reduce using rule 34 (termino -> factor .)
    NE              reduce using rule 34 (termino -> factor .)
    +               reduce using rule 34 (termino -> factor .)
    -               reduce using rule 34 (termino -> factor .)
    ;               reduce using rule 34 (termino -> factor .)
    ,               reduce using rule 34 (termino -> factor .)
    )               reduce using rule 34 (termino -> factor .)


state 58

    (20) factor -> ( . expression )
    (13) expression -> . exp > exp
    (14) expression -> . exp < exp
    (15) expression -> . exp EQ exp
    (16) expression -> . exp GE exp
    (17) expression -> . exp LE exp
    (18) expression -> . exp NE exp
    (19) expression -> . exp
    (10) exp -> . exp + termino
    (11) exp -> . exp - termino
    (12) exp -> . termino
    (32) termino -> . termino * factor
    (33) termino -> . termino / factor
    (34) termino -> . factor
    (20) factor -> . ( expression )
    (21) factor -> . ID
    (22) factor -> . cte
    (23) factor -> . + ID
    (24) factor -> . - ID
    (25) factor -> . + cte
    (26) factor -> . - cte
    (51) cte -> . CONST_INT
    (52) cte -> . CONST_FLOAT

    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    expression                     shift and go to state 89
    exp                            shift and go to state 53
    termino                        shift and go to state 55
    factor                         shift and go to state 57
    cte                            shift and go to state 59

state 59

    (22) factor -> cte .

    *               reduce using rule 22 (factor -> cte .)
    /               reduce using rule 22 (factor -> cte .)
    >               reduce using rule 22 (factor -> cte .)
    <               reduce using rule 22 (factor -> cte .)
    EQ              reduce using rule 22 (factor -> cte .)
    GE              reduce using rule 22 (factor -> cte .)
    LE              reduce using rule 22 (factor -> cte .)
    NE              reduce using rule 22 (factor -> cte .)
    +               reduce using rule 22 (factor -> cte .)
    -               reduce using rule 22 (factor -> cte .)
    ;               reduce using rule 22 (factor -> cte .)
    ,               reduce using rule 22 (factor -> cte .)
    )               reduce using rule 22 (factor -> cte .)


state 60

    (51) cte -> CONST_INT .

    *               reduce using rule 51 (cte -> CONST_INT .)
    /               reduce using rule 51 (cte -> CONST_INT .)
    >               reduce using rule 51 (cte -> CONST_INT .)
    <               reduce using rule 51 (cte -> CONST_INT .)
    EQ              reduce using rule 51 (cte -> CONST_INT .)
    GE              reduce using rule 51 (cte -> CONST_INT .)
    LE              reduce using rule 51 (cte -> CONST_INT .)
    NE              reduce using rule 51 (cte -> CONST_INT .)
    +               reduce using rule 51 (cte -> CONST_INT .)
    -               reduce using rule 51 (cte -> CONST_INT .)
    ;               reduce using rule 51 (cte -> CONST_INT .)
    ,               reduce using rule 51 (cte -> CONST_INT .)
    )               reduce using rule 51 (cte -> CONST_INT .)


state 61

    (52) cte -> CONST_FLOAT .

    *               reduce using rule 52 (cte -> CONST_FLOAT .)
    /               reduce using rule 52 (cte -> CONST_FLOAT .)
    >               reduce using rule 52 (cte -> CONST_FLOAT .)
    <               reduce using rule 52 (cte -> CONST_FLOAT .)
    EQ              reduce using rule 52 (cte -> CONST_FLOAT .)
    GE              reduce using rule 52 (cte -> CONST_FLOAT .)
    LE              reduce using rule 52 (cte -> CONST_FLOAT .)
    NE              reduce using rule 52 (cte -> CONST_FLOAT .)
    +               reduce using rule 52 (cte -> CONST_FLOAT .)
    -               reduce using rule 52 (cte -> CONST_FLOAT .)
    ;               reduce using rule 52 (cte -> CONST_FLOAT .)
    ,               reduce using rule 52 (cte -> CONST_FLOAT .)
    )               reduce using rule 52 (cte -> CONST_FLOAT .)


state 62

    (39) f_call -> ID ( expression . f_call_ayuda ) ;
    (41) f_call_ayuda -> . , expression f_call_ayuda
    (42) f_call_ayuda -> . empty
    (1) empty -> .

    ,               shift and go to state 91
    )               reduce using rule 1 (empty -> .)

    f_call_ayuda                   shift and go to state 90
    empty                          shift and go to state 92

state 63

    (40) f_call -> ID ( ) . ;

    ;               shift and go to state 93


state 64

    (36) condition -> IF ( expression . ) body ;
    (37) condition -> IF ( expression . ) body ELSE body ;

    )               shift and go to state 94


state 65

    (35) cycle -> DO body WHILE . ( expression ) ;

    (               shift and go to state 95


state 66

    (27) print -> PRINT ( expression . print_ayuda ) ;
    (29) print_ayuda -> . , expression print_ayuda
    (30) print_ayuda -> . , STRING print_ayuda
    (31) print_ayuda -> . empty
    (1) empty -> .

    ,               shift and go to state 97
    )               reduce using rule 1 (empty -> .)

    print_ayuda                    shift and go to state 96
    empty                          shift and go to state 98

state 67

    (28) print -> PRINT ( CONST_STRING . print_ayuda ) ;
    (29) print_ayuda -> . , expression print_ayuda
    (30) print_ayuda -> . , STRING print_ayuda
    (31) print_ayuda -> . empty
    (1) empty -> .

    ,               shift and go to state 97
    )               reduce using rule 1 (empty -> .)

    print_ayuda                    shift and go to state 99
    empty                          shift and go to state 98

state 68

    (53) funcs -> VOID ID ( ID : type . funcs_ayuda ) [ vars body ] ;
    (55) funcs -> VOID ID ( ID : type . funcs_ayuda ) [ body ] ;
    (59) funcs_ayuda -> . , ID : type funcs_ayuda
    (60) funcs_ayuda -> . empty
    (1) empty -> .

    ,               shift and go to state 101
    )               reduce using rule 1 (empty -> .)

    funcs_ayuda                    shift and go to state 100
    empty                          shift and go to state 102

state 69

    (54) funcs -> VOID ID ( ) [ vars . body ] ;
    (50) body -> . { statements }

    {               shift and go to state 19

    body                           shift and go to state 103

state 70

    (56) funcs -> VOID ID ( ) [ body . ] ;

    ]               shift and go to state 104


state 71

    (5) var_ayuda -> ID var_doble_ayuda : type ; var_ayuda_tail .

    VOID            reduce using rule 5 (var_ayuda -> ID var_doble_ayuda : type ; var_ayuda_tail .)
    MAIN            reduce using rule 5 (var_ayuda -> ID var_doble_ayuda : type ; var_ayuda_tail .)
    {               reduce using rule 5 (var_ayuda -> ID var_doble_ayuda : type ; var_ayuda_tail .)


state 72

    (6) var_ayuda_tail -> var_ayuda .

    VOID            reduce using rule 6 (var_ayuda_tail -> var_ayuda .)
    MAIN            reduce using rule 6 (var_ayuda_tail -> var_ayuda .)
    {               reduce using rule 6 (var_ayuda_tail -> var_ayuda .)


state 73

    (7) var_ayuda_tail -> empty .

    VOID            reduce using rule 7 (var_ayuda_tail -> empty .)
    MAIN            reduce using rule 7 (var_ayuda_tail -> empty .)
    {               reduce using rule 7 (var_ayuda_tail -> empty .)


state 74

    (38) assign -> ID = expression ; .

    }               reduce using rule 38 (assign -> ID = expression ; .)
    ID              reduce using rule 38 (assign -> ID = expression ; .)
    IF              reduce using rule 38 (assign -> ID = expression ; .)
    DO              reduce using rule 38 (assign -> ID = expression ; .)
    PRINT           reduce using rule 38 (assign -> ID = expression ; .)


state 75

    (13) expression -> exp > . exp
    (10) exp -> . exp + termino
    (11) exp -> . exp - termino
    (12) exp -> . termino
    (32) termino -> . termino * factor
    (33) termino -> . termino / factor
    (34) termino -> . factor
    (20) factor -> . ( expression )
    (21) factor -> . ID
    (22) factor -> . cte
    (23) factor -> . + ID
    (24) factor -> . - ID
    (25) factor -> . + cte
    (26) factor -> . - cte
    (51) cte -> . CONST_INT
    (52) cte -> . CONST_FLOAT

    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    exp                            shift and go to state 105
    termino                        shift and go to state 55
    factor                         shift and go to state 57
    cte                            shift and go to state 59

state 76

    (14) expression -> exp < . exp
    (10) exp -> . exp + termino
    (11) exp -> . exp - termino
    (12) exp -> . termino
    (32) termino -> . termino * factor
    (33) termino -> . termino / factor
    (34) termino -> . factor
    (20) factor -> . ( expression )
    (21) factor -> . ID
    (22) factor -> . cte
    (23) factor -> . + ID
    (24) factor -> . - ID
    (25) factor -> . + cte
    (26) factor -> . - cte
    (51) cte -> . CONST_INT
    (52) cte -> . CONST_FLOAT

    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    exp                            shift and go to state 106
    termino                        shift and go to state 55
    factor                         shift and go to state 57
    cte                            shift and go to state 59

state 77

    (15) expression -> exp EQ . exp
    (10) exp -> . exp + termino
    (11) exp -> . exp - termino
    (12) exp -> . termino
    (32) termino -> . termino * factor
    (33) termino -> . termino / factor
    (34) termino -> . factor
    (20) factor -> . ( expression )
    (21) factor -> . ID
    (22) factor -> . cte
    (23) factor -> . + ID
    (24) factor -> . - ID
    (25) factor -> . + cte
    (26) factor -> . - cte
    (51) cte -> . CONST_INT
    (52) cte -> . CONST_FLOAT

    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    exp                            shift and go to state 107
    termino                        shift and go to state 55
    factor                         shift and go to state 57
    cte                            shift and go to state 59

state 78

    (16) expression -> exp GE . exp
    (10) exp -> . exp + termino
    (11) exp -> . exp - termino
    (12) exp -> . termino
    (32) termino -> . termino * factor
    (33) termino -> . termino / factor
    (34) termino -> . factor
    (20) factor -> . ( expression )
    (21) factor -> . ID
    (22) factor -> . cte
    (23) factor -> . + ID
    (24) factor -> . - ID
    (25) factor -> . + cte
    (26) factor -> . - cte
    (51) cte -> . CONST_INT
    (52) cte -> . CONST_FLOAT

    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    exp                            shift and go to state 108
    termino                        shift and go to state 55
    factor                         shift and go to state 57
    cte                            shift and go to state 59

state 79

    (17) expression -> exp LE . exp
    (10) exp -> . exp + termino
    (11) exp -> . exp - termino
    (12) exp -> . termino
    (32) termino -> . termino * factor
    (33) termino -> . termino / factor
    (34) termino -> . factor
    (20) factor -> . ( expression )
    (21) factor -> . ID
    (22) factor -> . cte
    (23) factor -> . + ID
    (24) factor -> . - ID
    (25) factor -> . + cte
    (26) factor -> . - cte
    (51) cte -> . CONST_INT
    (52) cte -> . CONST_FLOAT

    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    exp                            shift and go to state 109
    termino                        shift and go to state 55
    factor                         shift and go to state 57
    cte                            shift and go to state 59

state 80

    (18) expression -> exp NE . exp
    (10) exp -> . exp + termino
    (11) exp -> . exp - termino
    (12) exp -> . termino
    (32) termino -> . termino * factor
    (33) termino -> . termino / factor
    (34) termino -> . factor
    (20) factor -> . ( expression )
    (21) factor -> . ID
    (22) factor -> . cte
    (23) factor -> . + ID
    (24) factor -> . - ID
    (25) factor -> . + cte
    (26) factor -> . - cte
    (51) cte -> . CONST_INT
    (52) cte -> . CONST_FLOAT

    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    exp                            shift and go to state 110
    termino                        shift and go to state 55
    factor                         shift and go to state 57
    cte                            shift and go to state 59

state 81

    (10) exp -> exp + . termino
    (32) termino -> . termino * factor
    (33) termino -> . termino / factor
    (34) termino -> . factor
    (20) factor -> . ( expression )
    (21) factor -> . ID
    (22) factor -> . cte
    (23) factor -> . + ID
    (24) factor -> . - ID
    (25) factor -> . + cte
    (26) factor -> . - cte
    (51) cte -> . CONST_INT
    (52) cte -> . CONST_FLOAT

    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    termino                        shift and go to state 111
    factor                         shift and go to state 57
    cte                            shift and go to state 59

state 82

    (11) exp -> exp - . termino
    (32) termino -> . termino * factor
    (33) termino -> . termino / factor
    (34) termino -> . factor
    (20) factor -> . ( expression )
    (21) factor -> . ID
    (22) factor -> . cte
    (23) factor -> . + ID
    (24) factor -> . - ID
    (25) factor -> . + cte
    (26) factor -> . - cte
    (51) cte -> . CONST_INT
    (52) cte -> . CONST_FLOAT

    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    termino                        shift and go to state 112
    factor                         shift and go to state 57
    cte                            shift and go to state 59

state 83

    (23) factor -> + ID .

    *               reduce using rule 23 (factor -> + ID .)
    /               reduce using rule 23 (factor -> + ID .)
    >               reduce using rule 23 (factor -> + ID .)
    <               reduce using rule 23 (factor -> + ID .)
    EQ              reduce using rule 23 (factor -> + ID .)
    GE              reduce using rule 23 (factor -> + ID .)
    LE              reduce using rule 23 (factor -> + ID .)
    NE              reduce using rule 23 (factor -> + ID .)
    +               reduce using rule 23 (factor -> + ID .)
    -               reduce using rule 23 (factor -> + ID .)
    ;               reduce using rule 23 (factor -> + ID .)
    ,               reduce using rule 23 (factor -> + ID .)
    )               reduce using rule 23 (factor -> + ID .)


state 84

    (25) factor -> + cte .

    *               reduce using rule 25 (factor -> + cte .)
    /               reduce using rule 25 (factor -> + cte .)
    >               reduce using rule 25 (factor -> + cte .)
    <               reduce using rule 25 (factor -> + cte .)
    EQ              reduce using rule 25 (factor -> + cte .)
    GE              reduce using rule 25 (factor -> + cte .)
    LE              reduce using rule 25 (factor -> + cte .)
    NE              reduce using rule 25 (factor -> + cte .)
    +               reduce using rule 25 (factor -> + cte .)
    -               reduce using rule 25 (factor -> + cte .)
    ;               reduce using rule 25 (factor -> + cte .)
    ,               reduce using rule 25 (factor -> + cte .)
    )               reduce using rule 25 (factor -> + cte .)


state 85

    (32) termino -> termino * . factor
    (20) factor -> . ( expression )
    (21) factor -> . ID
    (22) factor -> . cte
    (23) factor -> . + ID
    (24) factor -> . - ID
    (25) factor -> . + cte
    (26) factor -> . - cte
    (51) cte -> . CONST_INT
    (52) cte -> . CONST_FLOAT

    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    factor                         shift and go to state 113
    cte                            shift and go to state 59

state 86

    (33) termino -> termino / . factor
    (20) factor -> . ( expression )
    (21) factor -> . ID
    (22) factor -> . cte
    (23) factor -> . + ID
    (24) factor -> . - ID
    (25) factor -> . + cte
    (26) factor -> . - cte
    (51) cte -> . CONST_INT
    (52) cte -> . CONST_FLOAT

    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    factor                         shift and go to state 114
    cte                            shift and go to state 59

state 87

    (24) factor -> - ID .

    *               reduce using rule 24 (factor -> - ID .)
    /               reduce using rule 24 (factor -> - ID .)
    >               reduce using rule 24 (factor -> - ID .)
    <               reduce using rule 24 (factor -> - ID .)
    EQ              reduce using rule 24 (factor -> - ID .)
    GE              reduce using rule 24 (factor -> - ID .)
    LE              reduce using rule 24 (factor -> - ID .)
    NE              reduce using rule 24 (factor -> - ID .)
    +               reduce using rule 24 (factor -> - ID .)
    -               reduce using rule 24 (factor -> - ID .)
    ;               reduce using rule 24 (factor -> - ID .)
    ,               reduce using rule 24 (factor -> - ID .)
    )               reduce using rule 24 (factor -> - ID .)


state 88

    (26) factor -> - cte .

    *               reduce using rule 26 (factor -> - cte .)
    /               reduce using rule 26 (factor -> - cte .)
    >               reduce using rule 26 (factor -> - cte .)
    <               reduce using rule 26 (factor -> - cte .)
    EQ              reduce using rule 26 (factor -> - cte .)
    GE              reduce using rule 26 (factor -> - cte .)
    LE              reduce using rule 26 (factor -> - cte .)
    NE              reduce using rule 26 (factor -> - cte .)
    +               reduce using rule 26 (factor -> - cte .)
    -               reduce using rule 26 (factor -> - cte .)
    ;               reduce using rule 26 (factor -> - cte .)
    ,               reduce using rule 26 (factor -> - cte .)
    )               reduce using rule 26 (factor -> - cte .)


state 89

    (20) factor -> ( expression . )

    )               shift and go to state 115


state 90

    (39) f_call -> ID ( expression f_call_ayuda . ) ;

    )               shift and go to state 116


state 91

    (41) f_call_ayuda -> , . expression f_call_ayuda
    (13) expression -> . exp > exp
    (14) expression -> . exp < exp
    (15) expression -> . exp EQ exp
    (16) expression -> . exp GE exp
    (17) expression -> . exp LE exp
    (18) expression -> . exp NE exp
    (19) expression -> . exp
    (10) exp -> . exp + termino
    (11) exp -> . exp - termino
    (12) exp -> . termino
    (32) termino -> . termino * factor
    (33) termino -> . termino / factor
    (34) termino -> . factor
    (20) factor -> . ( expression )
    (21) factor -> . ID
    (22) factor -> . cte
    (23) factor -> . + ID
    (24) factor -> . - ID
    (25) factor -> . + cte
    (26) factor -> . - cte
    (51) cte -> . CONST_INT
    (52) cte -> . CONST_FLOAT

    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    expression                     shift and go to state 117
    exp                            shift and go to state 53
    termino                        shift and go to state 55
    factor                         shift and go to state 57
    cte                            shift and go to state 59

state 92

    (42) f_call_ayuda -> empty .

    )               reduce using rule 42 (f_call_ayuda -> empty .)


state 93

    (40) f_call -> ID ( ) ; .

    }               reduce using rule 40 (f_call -> ID ( ) ; .)
    ID              reduce using rule 40 (f_call -> ID ( ) ; .)
    IF              reduce using rule 40 (f_call -> ID ( ) ; .)
    DO              reduce using rule 40 (f_call -> ID ( ) ; .)
    PRINT           reduce using rule 40 (f_call -> ID ( ) ; .)


state 94

    (36) condition -> IF ( expression ) . body ;
    (37) condition -> IF ( expression ) . body ELSE body ;
    (50) body -> . { statements }

    {               shift and go to state 19

    body                           shift and go to state 118

state 95

    (35) cycle -> DO body WHILE ( . expression ) ;
    (13) expression -> . exp > exp
    (14) expression -> . exp < exp
    (15) expression -> . exp EQ exp
    (16) expression -> . exp GE exp
    (17) expression -> . exp LE exp
    (18) expression -> . exp NE exp
    (19) expression -> . exp
    (10) exp -> . exp + termino
    (11) exp -> . exp - termino
    (12) exp -> . termino
    (32) termino -> . termino * factor
    (33) termino -> . termino / factor
    (34) termino -> . factor
    (20) factor -> . ( expression )
    (21) factor -> . ID
    (22) factor -> . cte
    (23) factor -> . + ID
    (24) factor -> . - ID
    (25) factor -> . + cte
    (26) factor -> . - cte
    (51) cte -> . CONST_INT
    (52) cte -> . CONST_FLOAT

    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    expression                     shift and go to state 119
    exp                            shift and go to state 53
    termino                        shift and go to state 55
    factor                         shift and go to state 57
    cte                            shift and go to state 59

state 96

    (27) print -> PRINT ( expression print_ayuda . ) ;

    )               shift and go to state 120


state 97

    (29) print_ayuda -> , . expression print_ayuda
    (30) print_ayuda -> , . STRING print_ayuda
    (13) expression -> . exp > exp
    (14) expression -> . exp < exp
    (15) expression -> . exp EQ exp
    (16) expression -> . exp GE exp
    (17) expression -> . exp LE exp
    (18) expression -> . exp NE exp
    (19) expression -> . exp
    (10) exp -> . exp + termino
    (11) exp -> . exp - termino
    (12) exp -> . termino
    (32) termino -> . termino * factor
    (33) termino -> . termino / factor
    (34) termino -> . factor
    (20) factor -> . ( expression )
    (21) factor -> . ID
    (22) factor -> . cte
    (23) factor -> . + ID
    (24) factor -> . - ID
    (25) factor -> . + cte
    (26) factor -> . - cte
    (51) cte -> . CONST_INT
    (52) cte -> . CONST_FLOAT

    STRING          shift and go to state 122
    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    expression                     shift and go to state 121
    exp                            shift and go to state 53
    termino                        shift and go to state 55
    factor                         shift and go to state 57
    cte                            shift and go to state 59

state 98

    (31) print_ayuda -> empty .

    )               reduce using rule 31 (print_ayuda -> empty .)


state 99

    (28) print -> PRINT ( CONST_STRING print_ayuda . ) ;

    )               shift and go to state 123


state 100

    (53) funcs -> VOID ID ( ID : type funcs_ayuda . ) [ vars body ] ;
    (55) funcs -> VOID ID ( ID : type funcs_ayuda . ) [ body ] ;

    )               shift and go to state 124


state 101

    (59) funcs_ayuda -> , . ID : type funcs_ayuda

    ID              shift and go to state 125


state 102

    (60) funcs_ayuda -> empty .

    )               reduce using rule 60 (funcs_ayuda -> empty .)


state 103

    (54) funcs -> VOID ID ( ) [ vars body . ] ;

    ]               shift and go to state 126


state 104

    (56) funcs -> VOID ID ( ) [ body ] . ;

    ;               shift and go to state 127


state 105

    (13) expression -> exp > exp .
    (10) exp -> exp . + termino
    (11) exp -> exp . - termino

    ;               reduce using rule 13 (expression -> exp > exp .)
    ,               reduce using rule 13 (expression -> exp > exp .)
    )               reduce using rule 13 (expression -> exp > exp .)
    +               shift and go to state 81
    -               shift and go to state 82


state 106

    (14) expression -> exp < exp .
    (10) exp -> exp . + termino
    (11) exp -> exp . - termino

    ;               reduce using rule 14 (expression -> exp < exp .)
    ,               reduce using rule 14 (expression -> exp < exp .)
    )               reduce using rule 14 (expression -> exp < exp .)
    +               shift and go to state 81
    -               shift and go to state 82


state 107

    (15) expression -> exp EQ exp .
    (10) exp -> exp . + termino
    (11) exp -> exp . - termino

    ;               reduce using rule 15 (expression -> exp EQ exp .)
    ,               reduce using rule 15 (expression -> exp EQ exp .)
    )               reduce using rule 15 (expression -> exp EQ exp .)
    +               shift and go to state 81
    -               shift and go to state 82


state 108

    (16) expression -> exp GE exp .
    (10) exp -> exp . + termino
    (11) exp -> exp . - termino

    ;               reduce using rule 16 (expression -> exp GE exp .)
    ,               reduce using rule 16 (expression -> exp GE exp .)
    )               reduce using rule 16 (expression -> exp GE exp .)
    +               shift and go to state 81
    -               shift and go to state 82


state 109

    (17) expression -> exp LE exp .
    (10) exp -> exp . + termino
    (11) exp -> exp . - termino

    ;               reduce using rule 17 (expression -> exp LE exp .)
    ,               reduce using rule 17 (expression -> exp LE exp .)
    )               reduce using rule 17 (expression -> exp LE exp .)
    +               shift and go to state 81
    -               shift and go to state 82


state 110

    (18) expression -> exp NE exp .
    (10) exp -> exp . + termino
    (11) exp -> exp . - termino

    ;               reduce using rule 18 (expression -> exp NE exp .)
    ,               reduce using rule 18 (expression -> exp NE exp .)
    )               reduce using rule 18 (expression -> exp NE exp .)
    +               shift and go to state 81
    -               shift and go to state 82


state 111

    (10) exp -> exp + termino .
    (32) termino -> termino . * factor
    (33) termino -> termino . / factor

    >               reduce using rule 10 (exp -> exp + termino .)
    <               reduce using rule 10 (exp -> exp + termino .)
    EQ              reduce using rule 10 (exp -> exp + termino .)
    GE              reduce using rule 10 (exp -> exp + termino .)
    LE              reduce using rule 10 (exp -> exp + termino .)
    NE              reduce using rule 10 (exp -> exp + termino .)
    +               reduce using rule 10 (exp -> exp + termino .)
    -               reduce using rule 10 (exp -> exp + termino .)
    ;               reduce using rule 10 (exp -> exp + termino .)
    ,               reduce using rule 10 (exp -> exp + termino .)
    )               reduce using rule 10 (exp -> exp + termino .)
    *               shift and go to state 85
    /               shift and go to state 86


state 112

    (11) exp -> exp - termino .
    (32) termino -> termino . * factor
    (33) termino -> termino . / factor

    >               reduce using rule 11 (exp -> exp - termino .)
    <               reduce using rule 11 (exp -> exp - termino .)
    EQ              reduce using rule 11 (exp -> exp - termino .)
    GE              reduce using rule 11 (exp -> exp - termino .)
    LE              reduce using rule 11 (exp -> exp - termino .)
    NE              reduce using rule 11 (exp -> exp - termino .)
    +               reduce using rule 11 (exp -> exp - termino .)
    -               reduce using rule 11 (exp -> exp - termino .)
    ;               reduce using rule 11 (exp -> exp - termino .)
    ,               reduce using rule 11 (exp -> exp - termino .)
    )               reduce using rule 11 (exp -> exp - termino .)
    *               shift and go to state 85
    /               shift and go to state 86


state 113

    (32) termino -> termino * factor .

    *               reduce using rule 32 (termino -> termino * factor .)
    /               reduce using rule 32 (termino -> termino * factor .)
    >               reduce using rule 32 (termino -> termino * factor .)
    <               reduce using rule 32 (termino -> termino * factor .)
    EQ              reduce using rule 32 (termino -> termino * factor .)
    GE              reduce using rule 32 (termino -> termino * factor .)
    LE              reduce using rule 32 (termino -> termino * factor .)
    NE              reduce using rule 32 (termino -> termino * factor .)
    +               reduce using rule 32 (termino -> termino * factor .)
    -               reduce using rule 32 (termino -> termino * factor .)
    ;               reduce using rule 32 (termino -> termino * factor .)
    ,               reduce using rule 32 (termino -> termino * factor .)
    )               reduce using rule 32 (termino -> termino * factor .)


state 114

    (33) termino -> termino / factor .

    *               reduce using rule 33 (termino -> termino / factor .)
    /               reduce using rule 33 (termino -> termino / factor .)
    >               reduce using rule 33 (termino -> termino / factor .)
    <               reduce using rule 33 (termino -> termino / factor .)
    EQ              reduce using rule 33 (termino -> termino / factor .)
    GE              reduce using rule 33 (termino -> termino / factor .)
    LE              reduce using rule 33 (termino -> termino / factor .)
    NE              reduce using rule 33 (termino -> termino / factor .)
    +               reduce using rule 33 (termino -> termino / factor .)
    -               reduce using rule 33 (termino -> termino / factor .)
    ;               reduce using rule 33 (termino -> termino / factor .)
    ,               reduce using rule 33 (termino -> termino / factor .)
    )               reduce using rule 33 (termino -> termino / factor .)


state 115

    (20) factor -> ( expression ) .

    *               reduce using rule 20 (factor -> ( expression ) .)
    /               reduce using rule 20 (factor -> ( expression ) .)
    >               reduce using rule 20 (factor -> ( expression ) .)
    <               reduce using rule 20 (factor -> ( expression ) .)
    EQ              reduce using rule 20 (factor -> ( expression ) .)
    GE              reduce using rule 20 (factor -> ( expression ) .)
    LE              reduce using rule 20 (factor -> ( expression ) .)
    NE              reduce using rule 20 (factor -> ( expression ) .)
    +               reduce using rule 20 (factor -> ( expression ) .)
    -               reduce using rule 20 (factor -> ( expression ) .)
    ;               reduce using rule 20 (factor -> ( expression ) .)
    ,               reduce using rule 20 (factor -> ( expression ) .)
    )               reduce using rule 20 (factor -> ( expression ) .)


state 116

    (39) f_call -> ID ( expression f_call_ayuda ) . ;

    ;               shift and go to state 128


state 117

    (41) f_call_ayuda -> , expression . f_call_ayuda
    (41) f_call_ayuda -> . , expression f_call_ayuda
    (42) f_call_ayuda -> . empty
    (1) empty -> .

    ,               shift and go to state 91
    )               reduce using rule 1 (empty -> .)

    f_call_ayuda                   shift and go to state 129
    empty                          shift and go to state 92

state 118

    (36) condition -> IF ( expression ) body . ;
    (37) condition -> IF ( expression ) body . ELSE body ;

    ;               shift and go to state 130
    ELSE            shift and go to state 131


state 119

    (35) cycle -> DO body WHILE ( expression . ) ;

    )               shift and go to state 132


state 120

    (27) print -> PRINT ( expression print_ayuda ) . ;

    ;               shift and go to state 133


state 121

    (29) print_ayuda -> , expression . print_ayuda
    (29) print_ayuda -> . , expression print_ayuda
    (30) print_ayuda -> . , STRING print_ayuda
    (31) print_ayuda -> . empty
    (1) empty -> .

    ,               shift and go to state 97
    )               reduce using rule 1 (empty -> .)

    print_ayuda                    shift and go to state 134
    empty                          shift and go to state 98

state 122

    (30) print_ayuda -> , STRING . print_ayuda
    (29) print_ayuda -> . , expression print_ayuda
    (30) print_ayuda -> . , STRING print_ayuda
    (31) print_ayuda -> . empty
    (1) empty -> .

    ,               shift and go to state 97
    )               reduce using rule 1 (empty -> .)

    print_ayuda                    shift and go to state 135
    empty                          shift and go to state 98

state 123

    (28) print -> PRINT ( CONST_STRING print_ayuda ) . ;

    ;               shift and go to state 136


state 124

    (53) funcs -> VOID ID ( ID : type funcs_ayuda ) . [ vars body ] ;
    (55) funcs -> VOID ID ( ID : type funcs_ayuda ) . [ body ] ;

    [               shift and go to state 137


state 125

    (59) funcs_ayuda -> , ID . : type funcs_ayuda

    :               shift and go to state 138


state 126

    (54) funcs -> VOID ID ( ) [ vars body ] . ;

    ;               shift and go to state 139


state 127

    (56) funcs -> VOID ID ( ) [ body ] ; .

    MAIN            reduce using rule 56 (funcs -> VOID ID ( ) [ body ] ; .)
    VOID            reduce using rule 56 (funcs -> VOID ID ( ) [ body ] ; .)


state 128

    (39) f_call -> ID ( expression f_call_ayuda ) ; .

    }               reduce using rule 39 (f_call -> ID ( expression f_call_ayuda ) ; .)
    ID              reduce using rule 39 (f_call -> ID ( expression f_call_ayuda ) ; .)
    IF              reduce using rule 39 (f_call -> ID ( expression f_call_ayuda ) ; .)
    DO              reduce using rule 39 (f_call -> ID ( expression f_call_ayuda ) ; .)
    PRINT           reduce using rule 39 (f_call -> ID ( expression f_call_ayuda ) ; .)


state 129

    (41) f_call_ayuda -> , expression f_call_ayuda .

    )               reduce using rule 41 (f_call_ayuda -> , expression f_call_ayuda .)


state 130

    (36) condition -> IF ( expression ) body ; .

    }               reduce using rule 36 (condition -> IF ( expression ) body ; .)
    ID              reduce using rule 36 (condition -> IF ( expression ) body ; .)
    IF              reduce using rule 36 (condition -> IF ( expression ) body ; .)
    DO              reduce using rule 36 (condition -> IF ( expression ) body ; .)
    PRINT           reduce using rule 36 (condition -> IF ( expression ) body ; .)


state 131

    (37) condition -> IF ( expression ) body ELSE . body ;
    (50) body -> . { statements }

    {               shift and go to state 19

    body                           shift and go to state 140

state 132

    (35) cycle -> DO body WHILE ( expression ) . ;

    ;               shift and go to state 141


state 133

    (27) print -> PRINT ( expression print_ayuda ) ; .

    }               reduce using rule 27 (print -> PRINT ( expression print_ayuda ) ; .)
    ID              reduce using rule 27 (print -> PRINT ( expression print_ayuda ) ; .)
    IF              reduce using rule 27 (print -> PRINT ( expression print_ayuda ) ; .)
    DO              reduce using rule 27 (print -> PRINT ( expression print_ayuda ) ; .)
    PRINT           reduce using rule 27 (print -> PRINT ( expression print_ayuda ) ; .)


state 134

    (29) print_ayuda -> , expression print_ayuda .

    )               reduce using rule 29 (print_ayuda -> , expression print_ayuda .)


state 135

    (30) print_ayuda -> , STRING print_ayuda .

    )               reduce using rule 30 (print_ayuda -> , STRING print_ayuda .)


state 136

    (28) print -> PRINT ( CONST_STRING print_ayuda ) ; .

    }               reduce using rule 28 (print -> PRINT ( CONST_STRING print_ayuda ) ; .)
    ID              reduce using rule 28 (print -> PRINT ( CONST_STRING print_ayuda ) ; .)
    IF              reduce using rule 28 (print -> PRINT ( CONST_STRING print_ayuda ) ; .)
    DO              reduce using rule 28 (print -> PRINT ( CONST_STRING print_ayuda ) ; .)
    PRINT           reduce using rule 28 (print -> PRINT ( CONST_STRING print_ayuda ) ; .)


state 137

    (53) funcs -> VOID ID ( ID : type funcs_ayuda ) [ . vars body ] ;
    (55) funcs -> VOID ID ( ID : type funcs_ayuda ) [ . body ] ;
    (4) vars -> . VAR var_ayuda
    (50) body -> . { statements }

    VAR             shift and go to state 6
    {               shift and go to state 19

    vars                           shift and go to state 142
    body                           shift and go to state 143

state 138

    (59) funcs_ayuda -> , ID : . type funcs_ayuda
    (2) type -> . INT
    (3) type -> . FLOAT

    INT             shift and go to state 38
    FLOAT           shift and go to state 39

    type                           shift and go to state 144

state 139

    (54) funcs -> VOID ID ( ) [ vars body ] ; .

    MAIN            reduce using rule 54 (funcs -> VOID ID ( ) [ vars body ] ; .)
    VOID            reduce using rule 54 (funcs -> VOID ID ( ) [ vars body ] ; .)


state 140

    (37) condition -> IF ( expression ) body ELSE body . ;

    ;               shift and go to state 145


state 141

    (35) cycle -> DO body WHILE ( expression ) ; .

    }               reduce using rule 35 (cycle -> DO body WHILE ( expression ) ; .)
    ID              reduce using rule 35 (cycle -> DO body WHILE ( expression ) ; .)
    IF              reduce using rule 35 (cycle -> DO body WHILE ( expression ) ; .)
    DO              reduce using rule 35 (cycle -> DO body WHILE ( expression ) ; .)
    PRINT           reduce using rule 35 (cycle -> DO body WHILE ( expression ) ; .)


state 142

    (53) funcs -> VOID ID ( ID : type funcs_ayuda ) [ vars . body ] ;
    (50) body -> . { statements }

    {               shift and go to state 19

    body                           shift and go to state 146

state 143

    (55) funcs -> VOID ID ( ID : type funcs_ayuda ) [ body . ] ;

    ]               shift and go to state 147


state 144

    (59) funcs_ayuda -> , ID : type . funcs_ayuda
    (59) funcs_ayuda -> . , ID : type funcs_ayuda
    (60) funcs_ayuda -> . empty
    (1) empty -> .

    ,               shift and go to state 101
    )               reduce using rule 1 (empty -> .)

    funcs_ayuda                    shift and go to state 148
    empty                          shift and go to state 102

state 145

    (37) condition -> IF ( expression ) body ELSE body ; .

    }               reduce using rule 37 (condition -> IF ( expression ) body ELSE body ; .)
    ID              reduce using rule 37 (condition -> IF ( expression ) body ELSE body ; .)
    IF              reduce using rule 37 (condition -> IF ( expression ) body ELSE body ; .)
    DO              reduce using rule 37 (condition -> IF ( expression ) body ELSE body ; .)
    PRINT           reduce using rule 37 (condition -> IF ( expression ) body ELSE body ; .)


state 146

    (53) funcs -> VOID ID ( ID : type funcs_ayuda ) [ vars body . ] ;

    ]               shift and go to state 149


state 147

    (55) funcs -> VOID ID ( ID : type funcs_ayuda ) [ body ] . ;

    ;               shift and go to state 150


state 148

    (59) funcs_ayuda -> , ID : type funcs_ayuda .

    )               reduce using rule 59 (funcs_ayuda -> , ID : type funcs_ayuda .)


state 149

    (53) funcs -> VOID ID ( ID : type funcs_ayuda ) [ vars body ] . ;

    ;               shift and go to state 151


state 150

    (55) funcs -> VOID ID ( ID : type funcs_ayuda ) [ body ] ; .

    MAIN            reduce using rule 55 (funcs -> VOID ID ( ID : type funcs_ayuda ) [ body ] ; .)
    VOID            reduce using rule 55 (funcs -> VOID ID ( ID : type funcs_ayuda ) [ body ] ; .)


state 151

    (53) funcs -> VOID ID ( ID : type funcs_ayuda ) [ vars body ] ; .

    MAIN            reduce using rule 53 (funcs -> VOID ID ( ID : type funcs_ayuda ) [ vars body ] ; .)
    VOID            reduce using rule 53 (funcs -> VOID ID ( ID : type funcs_ayuda ) [ vars body ] ; .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for VOID in state 5 resolved as shift
WARNING: shift/reduce conflict for VOID in state 7 resolved as shift
WARNING: shift/reduce conflict for MAIN in state 7 resolved as shift
WARNING: shift/reduce conflict for VOID in state 12 resolved as shift
WARNING: shift/reduce conflict for VOID in state 12 resolved as shift
WARNING: reduce/reduce conflict in state 12 resolved using rule (empty -> <empty>)
WARNING: rejected rule (funcs -> funcs funcs) in state 12
WARNING: Rule (funcs -> funcs funcs) is never reduced
