Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    FOR
    THEN

Grammar

Rule 0     S' -> program
Rule 1     save_gotoF -> <empty>
Rule 2     empty -> <empty>
Rule 3     type -> INT
Rule 4     type -> FLOAT
Rule 5     vars -> VAR var_ayuda
Rule 6     var_ayuda -> ID var_doble_ayuda : type ; var_ayuda_tail
Rule 7     var_ayuda_tail -> var_ayuda
Rule 8     var_ayuda_tail -> empty
Rule 9     var_doble_ayuda -> , ID var_doble_ayuda
Rule 10    var_doble_ayuda -> empty
Rule 11    exp -> exp + termino
Rule 12    exp -> exp - termino
Rule 13    exp -> termino
Rule 14    expression -> exp > exp
Rule 15    expression -> exp < exp
Rule 16    expression -> exp EQ exp
Rule 17    expression -> exp GE exp
Rule 18    expression -> exp LE exp
Rule 19    expression -> exp NE exp
Rule 20    expression -> exp
Rule 21    factor -> ( expression )
Rule 22    factor -> ID
Rule 23    factor -> cte
Rule 24    factor -> + ID
Rule 25    factor -> - ID
Rule 26    factor -> + cte
Rule 27    factor -> - cte
Rule 28    print -> PRINT ( expression print_ayuda ) ;
Rule 29    print -> PRINT ( CONST_STRING print_ayuda ) ;
Rule 30    print_ayuda -> , expression print_ayuda
Rule 31    print_ayuda -> , STRING print_ayuda
Rule 32    print_ayuda -> empty
Rule 33    termino -> termino * factor
Rule 34    termino -> termino / factor
Rule 35    termino -> factor
Rule 36    cycle -> DO body WHILE ( expression ) ;
Rule 37    condition -> IF ( expression marca ) body ;
Rule 38    marca -> <empty>
Rule 39    condition -> IF ( expression ) save_gotof body save_goto_else ELSE body ;
Rule 40    save_gotof -> <empty>
Rule 41    save_goto_else -> <empty>
Rule 42    assign -> ID = expression ;
Rule 43    f_call -> ID ( expression f_call_ayuda ) ;
Rule 44    f_call -> ID ( ) ;
Rule 45    f_call_ayuda -> , expression f_call_ayuda
Rule 46    f_call_ayuda -> empty
Rule 47    statements -> statements statement
Rule 48    statements -> statement
Rule 49    statement -> assign
Rule 50    statement -> condition
Rule 51    statement -> cycle
Rule 52    statement -> f_call
Rule 53    statement -> print
Rule 54    body -> { statements }
Rule 55    cte -> CONST_INT
Rule 56    cte -> CONST_FLOAT
Rule 57    funcs -> VOID ID ( ID : type funcs_ayuda ) [ vars body ] ;
Rule 58    funcs -> VOID ID ( ) [ vars body ] ;
Rule 59    funcs -> VOID ID ( ID : type funcs_ayuda ) [ body ] ;
Rule 60    funcs -> VOID ID ( ) [ body ] ;
Rule 61    funcs -> funcs funcs
Rule 62    funcs -> empty
Rule 63    funcs_ayuda -> , ID : type funcs_ayuda
Rule 64    funcs_ayuda -> empty
Rule 65    program -> PROGRAM ID ; vars funcs MAIN body END

Terminals, with rules where they appear

(                    : 21 28 29 36 37 39 43 44 57 58 59 60
)                    : 21 28 29 36 37 39 43 44 57 58 59 60
*                    : 33
+                    : 11 24 26
,                    : 9 30 31 45 63
-                    : 12 25 27
/                    : 34
:                    : 6 57 59 63
;                    : 6 28 29 36 37 39 42 43 44 57 58 59 60 65
<                    : 15
=                    : 42
>                    : 14
CONST_FLOAT          : 56
CONST_INT            : 55
CONST_STRING         : 29
DO                   : 36
ELSE                 : 39
END                  : 65
EQ                   : 16
FLOAT                : 4
FOR                  : 
GE                   : 17
ID                   : 6 9 22 24 25 42 43 44 57 57 58 59 59 60 63 65
IF                   : 37 39
INT                  : 3
LE                   : 18
MAIN                 : 65
NE                   : 19
PRINT                : 28 29
PROGRAM              : 65
STRING               : 31
THEN                 : 
VAR                  : 5
VOID                 : 57 58 59 60
WHILE                : 36
[                    : 57 58 59 60
]                    : 57 58 59 60
error                : 
{                    : 54
}                    : 54

Nonterminals, with rules where they appear

assign               : 49
body                 : 36 37 39 39 57 58 59 60 65
condition            : 50
cte                  : 23 26 27
cycle                : 51
empty                : 8 10 32 46 62 64
exp                  : 11 12 14 14 15 15 16 16 17 17 18 18 19 19 20
expression           : 21 28 30 36 37 39 42 43 45
f_call               : 52
f_call_ayuda         : 43 45
factor               : 33 34 35
funcs                : 61 61 65
funcs_ayuda          : 57 59 63
marca                : 37
print                : 53
print_ayuda          : 28 29 30 31
program              : 0
save_gotoF           : 
save_goto_else       : 39
save_gotof           : 39
statement            : 47 48
statements           : 47 54
termino              : 11 12 13 33 34
type                 : 6 57 59 63
var_ayuda            : 5 7
var_ayuda_tail       : 6
var_doble_ayuda      : 6 9
vars                 : 57 58 65

Parsing method: LALR

state 0

    (0) S' -> . program
    (65) program -> . PROGRAM ID ; vars funcs MAIN body END

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (65) program -> PROGRAM . ID ; vars funcs MAIN body END

    ID              shift and go to state 3


state 3

    (65) program -> PROGRAM ID . ; vars funcs MAIN body END

    ;               shift and go to state 4


state 4

    (65) program -> PROGRAM ID ; . vars funcs MAIN body END
    (5) vars -> . VAR var_ayuda

    VAR             shift and go to state 6

    vars                           shift and go to state 5

state 5

    (65) program -> PROGRAM ID ; vars . funcs MAIN body END
    (57) funcs -> . VOID ID ( ID : type funcs_ayuda ) [ vars body ] ;
    (58) funcs -> . VOID ID ( ) [ vars body ] ;
    (59) funcs -> . VOID ID ( ID : type funcs_ayuda ) [ body ] ;
    (60) funcs -> . VOID ID ( ) [ body ] ;
    (61) funcs -> . funcs funcs
    (62) funcs -> . empty
    (2) empty -> .

  ! shift/reduce conflict for VOID resolved as shift
    VOID            shift and go to state 8
    MAIN            reduce using rule 2 (empty -> .)

  ! VOID            [ reduce using rule 2 (empty -> .) ]

    funcs                          shift and go to state 7
    empty                          shift and go to state 9

state 6

    (5) vars -> VAR . var_ayuda
    (6) var_ayuda -> . ID var_doble_ayuda : type ; var_ayuda_tail

    ID              shift and go to state 11

    var_ayuda                      shift and go to state 10

state 7

    (65) program -> PROGRAM ID ; vars funcs . MAIN body END
    (61) funcs -> funcs . funcs
    (57) funcs -> . VOID ID ( ID : type funcs_ayuda ) [ vars body ] ;
    (58) funcs -> . VOID ID ( ) [ vars body ] ;
    (59) funcs -> . VOID ID ( ID : type funcs_ayuda ) [ body ] ;
    (60) funcs -> . VOID ID ( ) [ body ] ;
    (61) funcs -> . funcs funcs
    (62) funcs -> . empty
    (2) empty -> .

  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for MAIN resolved as shift
    MAIN            shift and go to state 13
    VOID            shift and go to state 8

  ! VOID            [ reduce using rule 2 (empty -> .) ]
  ! MAIN            [ reduce using rule 2 (empty -> .) ]

    funcs                          shift and go to state 12
    empty                          shift and go to state 9

state 8

    (57) funcs -> VOID . ID ( ID : type funcs_ayuda ) [ vars body ] ;
    (58) funcs -> VOID . ID ( ) [ vars body ] ;
    (59) funcs -> VOID . ID ( ID : type funcs_ayuda ) [ body ] ;
    (60) funcs -> VOID . ID ( ) [ body ] ;

    ID              shift and go to state 14


state 9

    (62) funcs -> empty .

    MAIN            reduce using rule 62 (funcs -> empty .)
    VOID            reduce using rule 62 (funcs -> empty .)


state 10

    (5) vars -> VAR var_ayuda .

    VOID            reduce using rule 5 (vars -> VAR var_ayuda .)
    MAIN            reduce using rule 5 (vars -> VAR var_ayuda .)
    {               reduce using rule 5 (vars -> VAR var_ayuda .)


state 11

    (6) var_ayuda -> ID . var_doble_ayuda : type ; var_ayuda_tail
    (9) var_doble_ayuda -> . , ID var_doble_ayuda
    (10) var_doble_ayuda -> . empty
    (2) empty -> .

    ,               shift and go to state 16
    :               reduce using rule 2 (empty -> .)

    var_doble_ayuda                shift and go to state 15
    empty                          shift and go to state 17

state 12

    (61) funcs -> funcs funcs .
    (61) funcs -> funcs . funcs
    (57) funcs -> . VOID ID ( ID : type funcs_ayuda ) [ vars body ] ;
    (58) funcs -> . VOID ID ( ) [ vars body ] ;
    (59) funcs -> . VOID ID ( ID : type funcs_ayuda ) [ body ] ;
    (60) funcs -> . VOID ID ( ) [ body ] ;
    (61) funcs -> . funcs funcs
    (62) funcs -> . empty
    (2) empty -> .

  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! reduce/reduce conflict for MAIN resolved using rule 2 (empty -> .)
    VOID            shift and go to state 8
    MAIN            reduce using rule 2 (empty -> .)

  ! MAIN            [ reduce using rule 61 (funcs -> funcs funcs .) ]
  ! VOID            [ reduce using rule 61 (funcs -> funcs funcs .) ]
  ! VOID            [ reduce using rule 2 (empty -> .) ]

    funcs                          shift and go to state 12
    empty                          shift and go to state 9

state 13

    (65) program -> PROGRAM ID ; vars funcs MAIN . body END
    (54) body -> . { statements }

    {               shift and go to state 19

    body                           shift and go to state 18

state 14

    (57) funcs -> VOID ID . ( ID : type funcs_ayuda ) [ vars body ] ;
    (58) funcs -> VOID ID . ( ) [ vars body ] ;
    (59) funcs -> VOID ID . ( ID : type funcs_ayuda ) [ body ] ;
    (60) funcs -> VOID ID . ( ) [ body ] ;

    (               shift and go to state 20


state 15

    (6) var_ayuda -> ID var_doble_ayuda . : type ; var_ayuda_tail

    :               shift and go to state 21


state 16

    (9) var_doble_ayuda -> , . ID var_doble_ayuda

    ID              shift and go to state 22


state 17

    (10) var_doble_ayuda -> empty .

    :               reduce using rule 10 (var_doble_ayuda -> empty .)


state 18

    (65) program -> PROGRAM ID ; vars funcs MAIN body . END

    END             shift and go to state 23


state 19

    (54) body -> { . statements }
    (47) statements -> . statements statement
    (48) statements -> . statement
    (49) statement -> . assign
    (50) statement -> . condition
    (51) statement -> . cycle
    (52) statement -> . f_call
    (53) statement -> . print
    (42) assign -> . ID = expression ;
    (37) condition -> . IF ( expression marca ) body ;
    (39) condition -> . IF ( expression ) save_gotof body save_goto_else ELSE body ;
    (36) cycle -> . DO body WHILE ( expression ) ;
    (43) f_call -> . ID ( expression f_call_ayuda ) ;
    (44) f_call -> . ID ( ) ;
    (28) print -> . PRINT ( expression print_ayuda ) ;
    (29) print -> . PRINT ( CONST_STRING print_ayuda ) ;

    ID              shift and go to state 31
    IF              shift and go to state 32
    DO              shift and go to state 33
    PRINT           shift and go to state 34

    statements                     shift and go to state 24
    statement                      shift and go to state 25
    assign                         shift and go to state 26
    condition                      shift and go to state 27
    cycle                          shift and go to state 28
    f_call                         shift and go to state 29
    print                          shift and go to state 30

state 20

    (57) funcs -> VOID ID ( . ID : type funcs_ayuda ) [ vars body ] ;
    (58) funcs -> VOID ID ( . ) [ vars body ] ;
    (59) funcs -> VOID ID ( . ID : type funcs_ayuda ) [ body ] ;
    (60) funcs -> VOID ID ( . ) [ body ] ;

    ID              shift and go to state 35
    )               shift and go to state 36


state 21

    (6) var_ayuda -> ID var_doble_ayuda : . type ; var_ayuda_tail
    (3) type -> . INT
    (4) type -> . FLOAT

    INT             shift and go to state 38
    FLOAT           shift and go to state 39

    type                           shift and go to state 37

state 22

    (9) var_doble_ayuda -> , ID . var_doble_ayuda
    (9) var_doble_ayuda -> . , ID var_doble_ayuda
    (10) var_doble_ayuda -> . empty
    (2) empty -> .

    ,               shift and go to state 16
    :               reduce using rule 2 (empty -> .)

    var_doble_ayuda                shift and go to state 40
    empty                          shift and go to state 17

state 23

    (65) program -> PROGRAM ID ; vars funcs MAIN body END .

    $end            reduce using rule 65 (program -> PROGRAM ID ; vars funcs MAIN body END .)


state 24

    (54) body -> { statements . }
    (47) statements -> statements . statement
    (49) statement -> . assign
    (50) statement -> . condition
    (51) statement -> . cycle
    (52) statement -> . f_call
    (53) statement -> . print
    (42) assign -> . ID = expression ;
    (37) condition -> . IF ( expression marca ) body ;
    (39) condition -> . IF ( expression ) save_gotof body save_goto_else ELSE body ;
    (36) cycle -> . DO body WHILE ( expression ) ;
    (43) f_call -> . ID ( expression f_call_ayuda ) ;
    (44) f_call -> . ID ( ) ;
    (28) print -> . PRINT ( expression print_ayuda ) ;
    (29) print -> . PRINT ( CONST_STRING print_ayuda ) ;

    }               shift and go to state 41
    ID              shift and go to state 31
    IF              shift and go to state 32
    DO              shift and go to state 33
    PRINT           shift and go to state 34

    statement                      shift and go to state 42
    assign                         shift and go to state 26
    condition                      shift and go to state 27
    cycle                          shift and go to state 28
    f_call                         shift and go to state 29
    print                          shift and go to state 30

state 25

    (48) statements -> statement .

    }               reduce using rule 48 (statements -> statement .)
    ID              reduce using rule 48 (statements -> statement .)
    IF              reduce using rule 48 (statements -> statement .)
    DO              reduce using rule 48 (statements -> statement .)
    PRINT           reduce using rule 48 (statements -> statement .)


state 26

    (49) statement -> assign .

    }               reduce using rule 49 (statement -> assign .)
    ID              reduce using rule 49 (statement -> assign .)
    IF              reduce using rule 49 (statement -> assign .)
    DO              reduce using rule 49 (statement -> assign .)
    PRINT           reduce using rule 49 (statement -> assign .)


state 27

    (50) statement -> condition .

    }               reduce using rule 50 (statement -> condition .)
    ID              reduce using rule 50 (statement -> condition .)
    IF              reduce using rule 50 (statement -> condition .)
    DO              reduce using rule 50 (statement -> condition .)
    PRINT           reduce using rule 50 (statement -> condition .)


state 28

    (51) statement -> cycle .

    }               reduce using rule 51 (statement -> cycle .)
    ID              reduce using rule 51 (statement -> cycle .)
    IF              reduce using rule 51 (statement -> cycle .)
    DO              reduce using rule 51 (statement -> cycle .)
    PRINT           reduce using rule 51 (statement -> cycle .)


state 29

    (52) statement -> f_call .

    }               reduce using rule 52 (statement -> f_call .)
    ID              reduce using rule 52 (statement -> f_call .)
    IF              reduce using rule 52 (statement -> f_call .)
    DO              reduce using rule 52 (statement -> f_call .)
    PRINT           reduce using rule 52 (statement -> f_call .)


state 30

    (53) statement -> print .

    }               reduce using rule 53 (statement -> print .)
    ID              reduce using rule 53 (statement -> print .)
    IF              reduce using rule 53 (statement -> print .)
    DO              reduce using rule 53 (statement -> print .)
    PRINT           reduce using rule 53 (statement -> print .)


state 31

    (42) assign -> ID . = expression ;
    (43) f_call -> ID . ( expression f_call_ayuda ) ;
    (44) f_call -> ID . ( ) ;

    =               shift and go to state 43
    (               shift and go to state 44


state 32

    (37) condition -> IF . ( expression marca ) body ;
    (39) condition -> IF . ( expression ) save_gotof body save_goto_else ELSE body ;

    (               shift and go to state 45


state 33

    (36) cycle -> DO . body WHILE ( expression ) ;
    (54) body -> . { statements }

    {               shift and go to state 19

    body                           shift and go to state 46

state 34

    (28) print -> PRINT . ( expression print_ayuda ) ;
    (29) print -> PRINT . ( CONST_STRING print_ayuda ) ;

    (               shift and go to state 47


state 35

    (57) funcs -> VOID ID ( ID . : type funcs_ayuda ) [ vars body ] ;
    (59) funcs -> VOID ID ( ID . : type funcs_ayuda ) [ body ] ;

    :               shift and go to state 48


state 36

    (58) funcs -> VOID ID ( ) . [ vars body ] ;
    (60) funcs -> VOID ID ( ) . [ body ] ;

    [               shift and go to state 49


state 37

    (6) var_ayuda -> ID var_doble_ayuda : type . ; var_ayuda_tail

    ;               shift and go to state 50


state 38

    (3) type -> INT .

    ;               reduce using rule 3 (type -> INT .)
    ,               reduce using rule 3 (type -> INT .)
    )               reduce using rule 3 (type -> INT .)


state 39

    (4) type -> FLOAT .

    ;               reduce using rule 4 (type -> FLOAT .)
    ,               reduce using rule 4 (type -> FLOAT .)
    )               reduce using rule 4 (type -> FLOAT .)


state 40

    (9) var_doble_ayuda -> , ID var_doble_ayuda .

    :               reduce using rule 9 (var_doble_ayuda -> , ID var_doble_ayuda .)


state 41

    (54) body -> { statements } .

    END             reduce using rule 54 (body -> { statements } .)
    WHILE           reduce using rule 54 (body -> { statements } .)
    ]               reduce using rule 54 (body -> { statements } .)
    ;               reduce using rule 54 (body -> { statements } .)
    ELSE            reduce using rule 54 (body -> { statements } .)


state 42

    (47) statements -> statements statement .

    }               reduce using rule 47 (statements -> statements statement .)
    ID              reduce using rule 47 (statements -> statements statement .)
    IF              reduce using rule 47 (statements -> statements statement .)
    DO              reduce using rule 47 (statements -> statements statement .)
    PRINT           reduce using rule 47 (statements -> statements statement .)


state 43

    (42) assign -> ID = . expression ;
    (14) expression -> . exp > exp
    (15) expression -> . exp < exp
    (16) expression -> . exp EQ exp
    (17) expression -> . exp GE exp
    (18) expression -> . exp LE exp
    (19) expression -> . exp NE exp
    (20) expression -> . exp
    (11) exp -> . exp + termino
    (12) exp -> . exp - termino
    (13) exp -> . termino
    (33) termino -> . termino * factor
    (34) termino -> . termino / factor
    (35) termino -> . factor
    (21) factor -> . ( expression )
    (22) factor -> . ID
    (23) factor -> . cte
    (24) factor -> . + ID
    (25) factor -> . - ID
    (26) factor -> . + cte
    (27) factor -> . - cte
    (55) cte -> . CONST_INT
    (56) cte -> . CONST_FLOAT

    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    expression                     shift and go to state 52
    exp                            shift and go to state 53
    termino                        shift and go to state 55
    factor                         shift and go to state 57
    cte                            shift and go to state 59

state 44

    (43) f_call -> ID ( . expression f_call_ayuda ) ;
    (44) f_call -> ID ( . ) ;
    (14) expression -> . exp > exp
    (15) expression -> . exp < exp
    (16) expression -> . exp EQ exp
    (17) expression -> . exp GE exp
    (18) expression -> . exp LE exp
    (19) expression -> . exp NE exp
    (20) expression -> . exp
    (11) exp -> . exp + termino
    (12) exp -> . exp - termino
    (13) exp -> . termino
    (33) termino -> . termino * factor
    (34) termino -> . termino / factor
    (35) termino -> . factor
    (21) factor -> . ( expression )
    (22) factor -> . ID
    (23) factor -> . cte
    (24) factor -> . + ID
    (25) factor -> . - ID
    (26) factor -> . + cte
    (27) factor -> . - cte
    (55) cte -> . CONST_INT
    (56) cte -> . CONST_FLOAT

    )               shift and go to state 63
    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    expression                     shift and go to state 62
    exp                            shift and go to state 53
    termino                        shift and go to state 55
    factor                         shift and go to state 57
    cte                            shift and go to state 59

state 45

    (37) condition -> IF ( . expression marca ) body ;
    (39) condition -> IF ( . expression ) save_gotof body save_goto_else ELSE body ;
    (14) expression -> . exp > exp
    (15) expression -> . exp < exp
    (16) expression -> . exp EQ exp
    (17) expression -> . exp GE exp
    (18) expression -> . exp LE exp
    (19) expression -> . exp NE exp
    (20) expression -> . exp
    (11) exp -> . exp + termino
    (12) exp -> . exp - termino
    (13) exp -> . termino
    (33) termino -> . termino * factor
    (34) termino -> . termino / factor
    (35) termino -> . factor
    (21) factor -> . ( expression )
    (22) factor -> . ID
    (23) factor -> . cte
    (24) factor -> . + ID
    (25) factor -> . - ID
    (26) factor -> . + cte
    (27) factor -> . - cte
    (55) cte -> . CONST_INT
    (56) cte -> . CONST_FLOAT

    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    expression                     shift and go to state 64
    exp                            shift and go to state 53
    termino                        shift and go to state 55
    factor                         shift and go to state 57
    cte                            shift and go to state 59

state 46

    (36) cycle -> DO body . WHILE ( expression ) ;

    WHILE           shift and go to state 65


state 47

    (28) print -> PRINT ( . expression print_ayuda ) ;
    (29) print -> PRINT ( . CONST_STRING print_ayuda ) ;
    (14) expression -> . exp > exp
    (15) expression -> . exp < exp
    (16) expression -> . exp EQ exp
    (17) expression -> . exp GE exp
    (18) expression -> . exp LE exp
    (19) expression -> . exp NE exp
    (20) expression -> . exp
    (11) exp -> . exp + termino
    (12) exp -> . exp - termino
    (13) exp -> . termino
    (33) termino -> . termino * factor
    (34) termino -> . termino / factor
    (35) termino -> . factor
    (21) factor -> . ( expression )
    (22) factor -> . ID
    (23) factor -> . cte
    (24) factor -> . + ID
    (25) factor -> . - ID
    (26) factor -> . + cte
    (27) factor -> . - cte
    (55) cte -> . CONST_INT
    (56) cte -> . CONST_FLOAT

    CONST_STRING    shift and go to state 67
    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    expression                     shift and go to state 66
    exp                            shift and go to state 53
    termino                        shift and go to state 55
    factor                         shift and go to state 57
    cte                            shift and go to state 59

state 48

    (57) funcs -> VOID ID ( ID : . type funcs_ayuda ) [ vars body ] ;
    (59) funcs -> VOID ID ( ID : . type funcs_ayuda ) [ body ] ;
    (3) type -> . INT
    (4) type -> . FLOAT

    INT             shift and go to state 38
    FLOAT           shift and go to state 39

    type                           shift and go to state 68

state 49

    (58) funcs -> VOID ID ( ) [ . vars body ] ;
    (60) funcs -> VOID ID ( ) [ . body ] ;
    (5) vars -> . VAR var_ayuda
    (54) body -> . { statements }

    VAR             shift and go to state 6
    {               shift and go to state 19

    vars                           shift and go to state 69
    body                           shift and go to state 70

state 50

    (6) var_ayuda -> ID var_doble_ayuda : type ; . var_ayuda_tail
    (7) var_ayuda_tail -> . var_ayuda
    (8) var_ayuda_tail -> . empty
    (6) var_ayuda -> . ID var_doble_ayuda : type ; var_ayuda_tail
    (2) empty -> .

    ID              shift and go to state 11
    VOID            reduce using rule 2 (empty -> .)
    MAIN            reduce using rule 2 (empty -> .)
    {               reduce using rule 2 (empty -> .)

    var_ayuda_tail                 shift and go to state 71
    var_ayuda                      shift and go to state 72
    empty                          shift and go to state 73

state 51

    (22) factor -> ID .

    *               reduce using rule 22 (factor -> ID .)
    /               reduce using rule 22 (factor -> ID .)
    >               reduce using rule 22 (factor -> ID .)
    <               reduce using rule 22 (factor -> ID .)
    EQ              reduce using rule 22 (factor -> ID .)
    GE              reduce using rule 22 (factor -> ID .)
    LE              reduce using rule 22 (factor -> ID .)
    NE              reduce using rule 22 (factor -> ID .)
    +               reduce using rule 22 (factor -> ID .)
    -               reduce using rule 22 (factor -> ID .)
    ;               reduce using rule 22 (factor -> ID .)
    ,               reduce using rule 22 (factor -> ID .)
    )               reduce using rule 22 (factor -> ID .)


state 52

    (42) assign -> ID = expression . ;

    ;               shift and go to state 74


state 53

    (14) expression -> exp . > exp
    (15) expression -> exp . < exp
    (16) expression -> exp . EQ exp
    (17) expression -> exp . GE exp
    (18) expression -> exp . LE exp
    (19) expression -> exp . NE exp
    (20) expression -> exp .
    (11) exp -> exp . + termino
    (12) exp -> exp . - termino

    >               shift and go to state 75
    <               shift and go to state 76
    EQ              shift and go to state 77
    GE              shift and go to state 78
    LE              shift and go to state 79
    NE              shift and go to state 80
    ;               reduce using rule 20 (expression -> exp .)
    ,               reduce using rule 20 (expression -> exp .)
    )               reduce using rule 20 (expression -> exp .)
    +               shift and go to state 81
    -               shift and go to state 82


state 54

    (24) factor -> + . ID
    (26) factor -> + . cte
    (55) cte -> . CONST_INT
    (56) cte -> . CONST_FLOAT

    ID              shift and go to state 83
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    cte                            shift and go to state 84

state 55

    (13) exp -> termino .
    (33) termino -> termino . * factor
    (34) termino -> termino . / factor

    >               reduce using rule 13 (exp -> termino .)
    <               reduce using rule 13 (exp -> termino .)
    EQ              reduce using rule 13 (exp -> termino .)
    GE              reduce using rule 13 (exp -> termino .)
    LE              reduce using rule 13 (exp -> termino .)
    NE              reduce using rule 13 (exp -> termino .)
    +               reduce using rule 13 (exp -> termino .)
    -               reduce using rule 13 (exp -> termino .)
    ;               reduce using rule 13 (exp -> termino .)
    ,               reduce using rule 13 (exp -> termino .)
    )               reduce using rule 13 (exp -> termino .)
    *               shift and go to state 85
    /               shift and go to state 86


state 56

    (25) factor -> - . ID
    (27) factor -> - . cte
    (55) cte -> . CONST_INT
    (56) cte -> . CONST_FLOAT

    ID              shift and go to state 87
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    cte                            shift and go to state 88

state 57

    (35) termino -> factor .

    *               reduce using rule 35 (termino -> factor .)
    /               reduce using rule 35 (termino -> factor .)
    >               reduce using rule 35 (termino -> factor .)
    <               reduce using rule 35 (termino -> factor .)
    EQ              reduce using rule 35 (termino -> factor .)
    GE              reduce using rule 35 (termino -> factor .)
    LE              reduce using rule 35 (termino -> factor .)
    NE              reduce using rule 35 (termino -> factor .)
    +               reduce using rule 35 (termino -> factor .)
    -               reduce using rule 35 (termino -> factor .)
    ;               reduce using rule 35 (termino -> factor .)
    ,               reduce using rule 35 (termino -> factor .)
    )               reduce using rule 35 (termino -> factor .)


state 58

    (21) factor -> ( . expression )
    (14) expression -> . exp > exp
    (15) expression -> . exp < exp
    (16) expression -> . exp EQ exp
    (17) expression -> . exp GE exp
    (18) expression -> . exp LE exp
    (19) expression -> . exp NE exp
    (20) expression -> . exp
    (11) exp -> . exp + termino
    (12) exp -> . exp - termino
    (13) exp -> . termino
    (33) termino -> . termino * factor
    (34) termino -> . termino / factor
    (35) termino -> . factor
    (21) factor -> . ( expression )
    (22) factor -> . ID
    (23) factor -> . cte
    (24) factor -> . + ID
    (25) factor -> . - ID
    (26) factor -> . + cte
    (27) factor -> . - cte
    (55) cte -> . CONST_INT
    (56) cte -> . CONST_FLOAT

    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    expression                     shift and go to state 89
    exp                            shift and go to state 53
    termino                        shift and go to state 55
    factor                         shift and go to state 57
    cte                            shift and go to state 59

state 59

    (23) factor -> cte .

    *               reduce using rule 23 (factor -> cte .)
    /               reduce using rule 23 (factor -> cte .)
    >               reduce using rule 23 (factor -> cte .)
    <               reduce using rule 23 (factor -> cte .)
    EQ              reduce using rule 23 (factor -> cte .)
    GE              reduce using rule 23 (factor -> cte .)
    LE              reduce using rule 23 (factor -> cte .)
    NE              reduce using rule 23 (factor -> cte .)
    +               reduce using rule 23 (factor -> cte .)
    -               reduce using rule 23 (factor -> cte .)
    ;               reduce using rule 23 (factor -> cte .)
    ,               reduce using rule 23 (factor -> cte .)
    )               reduce using rule 23 (factor -> cte .)


state 60

    (55) cte -> CONST_INT .

    *               reduce using rule 55 (cte -> CONST_INT .)
    /               reduce using rule 55 (cte -> CONST_INT .)
    >               reduce using rule 55 (cte -> CONST_INT .)
    <               reduce using rule 55 (cte -> CONST_INT .)
    EQ              reduce using rule 55 (cte -> CONST_INT .)
    GE              reduce using rule 55 (cte -> CONST_INT .)
    LE              reduce using rule 55 (cte -> CONST_INT .)
    NE              reduce using rule 55 (cte -> CONST_INT .)
    +               reduce using rule 55 (cte -> CONST_INT .)
    -               reduce using rule 55 (cte -> CONST_INT .)
    ;               reduce using rule 55 (cte -> CONST_INT .)
    ,               reduce using rule 55 (cte -> CONST_INT .)
    )               reduce using rule 55 (cte -> CONST_INT .)


state 61

    (56) cte -> CONST_FLOAT .

    *               reduce using rule 56 (cte -> CONST_FLOAT .)
    /               reduce using rule 56 (cte -> CONST_FLOAT .)
    >               reduce using rule 56 (cte -> CONST_FLOAT .)
    <               reduce using rule 56 (cte -> CONST_FLOAT .)
    EQ              reduce using rule 56 (cte -> CONST_FLOAT .)
    GE              reduce using rule 56 (cte -> CONST_FLOAT .)
    LE              reduce using rule 56 (cte -> CONST_FLOAT .)
    NE              reduce using rule 56 (cte -> CONST_FLOAT .)
    +               reduce using rule 56 (cte -> CONST_FLOAT .)
    -               reduce using rule 56 (cte -> CONST_FLOAT .)
    ;               reduce using rule 56 (cte -> CONST_FLOAT .)
    ,               reduce using rule 56 (cte -> CONST_FLOAT .)
    )               reduce using rule 56 (cte -> CONST_FLOAT .)


state 62

    (43) f_call -> ID ( expression . f_call_ayuda ) ;
    (45) f_call_ayuda -> . , expression f_call_ayuda
    (46) f_call_ayuda -> . empty
    (2) empty -> .

    ,               shift and go to state 91
    )               reduce using rule 2 (empty -> .)

    f_call_ayuda                   shift and go to state 90
    empty                          shift and go to state 92

state 63

    (44) f_call -> ID ( ) . ;

    ;               shift and go to state 93


state 64

    (37) condition -> IF ( expression . marca ) body ;
    (39) condition -> IF ( expression . ) save_gotof body save_goto_else ELSE body ;
    (38) marca -> .

  ! shift/reduce conflict for ) resolved as shift
    )               shift and go to state 95

  ! )               [ reduce using rule 38 (marca -> .) ]

    marca                          shift and go to state 94

state 65

    (36) cycle -> DO body WHILE . ( expression ) ;

    (               shift and go to state 96


state 66

    (28) print -> PRINT ( expression . print_ayuda ) ;
    (30) print_ayuda -> . , expression print_ayuda
    (31) print_ayuda -> . , STRING print_ayuda
    (32) print_ayuda -> . empty
    (2) empty -> .

    ,               shift and go to state 98
    )               reduce using rule 2 (empty -> .)

    print_ayuda                    shift and go to state 97
    empty                          shift and go to state 99

state 67

    (29) print -> PRINT ( CONST_STRING . print_ayuda ) ;
    (30) print_ayuda -> . , expression print_ayuda
    (31) print_ayuda -> . , STRING print_ayuda
    (32) print_ayuda -> . empty
    (2) empty -> .

    ,               shift and go to state 98
    )               reduce using rule 2 (empty -> .)

    print_ayuda                    shift and go to state 100
    empty                          shift and go to state 99

state 68

    (57) funcs -> VOID ID ( ID : type . funcs_ayuda ) [ vars body ] ;
    (59) funcs -> VOID ID ( ID : type . funcs_ayuda ) [ body ] ;
    (63) funcs_ayuda -> . , ID : type funcs_ayuda
    (64) funcs_ayuda -> . empty
    (2) empty -> .

    ,               shift and go to state 102
    )               reduce using rule 2 (empty -> .)

    funcs_ayuda                    shift and go to state 101
    empty                          shift and go to state 103

state 69

    (58) funcs -> VOID ID ( ) [ vars . body ] ;
    (54) body -> . { statements }

    {               shift and go to state 19

    body                           shift and go to state 104

state 70

    (60) funcs -> VOID ID ( ) [ body . ] ;

    ]               shift and go to state 105


state 71

    (6) var_ayuda -> ID var_doble_ayuda : type ; var_ayuda_tail .

    VOID            reduce using rule 6 (var_ayuda -> ID var_doble_ayuda : type ; var_ayuda_tail .)
    MAIN            reduce using rule 6 (var_ayuda -> ID var_doble_ayuda : type ; var_ayuda_tail .)
    {               reduce using rule 6 (var_ayuda -> ID var_doble_ayuda : type ; var_ayuda_tail .)


state 72

    (7) var_ayuda_tail -> var_ayuda .

    VOID            reduce using rule 7 (var_ayuda_tail -> var_ayuda .)
    MAIN            reduce using rule 7 (var_ayuda_tail -> var_ayuda .)
    {               reduce using rule 7 (var_ayuda_tail -> var_ayuda .)


state 73

    (8) var_ayuda_tail -> empty .

    VOID            reduce using rule 8 (var_ayuda_tail -> empty .)
    MAIN            reduce using rule 8 (var_ayuda_tail -> empty .)
    {               reduce using rule 8 (var_ayuda_tail -> empty .)


state 74

    (42) assign -> ID = expression ; .

    }               reduce using rule 42 (assign -> ID = expression ; .)
    ID              reduce using rule 42 (assign -> ID = expression ; .)
    IF              reduce using rule 42 (assign -> ID = expression ; .)
    DO              reduce using rule 42 (assign -> ID = expression ; .)
    PRINT           reduce using rule 42 (assign -> ID = expression ; .)


state 75

    (14) expression -> exp > . exp
    (11) exp -> . exp + termino
    (12) exp -> . exp - termino
    (13) exp -> . termino
    (33) termino -> . termino * factor
    (34) termino -> . termino / factor
    (35) termino -> . factor
    (21) factor -> . ( expression )
    (22) factor -> . ID
    (23) factor -> . cte
    (24) factor -> . + ID
    (25) factor -> . - ID
    (26) factor -> . + cte
    (27) factor -> . - cte
    (55) cte -> . CONST_INT
    (56) cte -> . CONST_FLOAT

    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    exp                            shift and go to state 106
    termino                        shift and go to state 55
    factor                         shift and go to state 57
    cte                            shift and go to state 59

state 76

    (15) expression -> exp < . exp
    (11) exp -> . exp + termino
    (12) exp -> . exp - termino
    (13) exp -> . termino
    (33) termino -> . termino * factor
    (34) termino -> . termino / factor
    (35) termino -> . factor
    (21) factor -> . ( expression )
    (22) factor -> . ID
    (23) factor -> . cte
    (24) factor -> . + ID
    (25) factor -> . - ID
    (26) factor -> . + cte
    (27) factor -> . - cte
    (55) cte -> . CONST_INT
    (56) cte -> . CONST_FLOAT

    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    exp                            shift and go to state 107
    termino                        shift and go to state 55
    factor                         shift and go to state 57
    cte                            shift and go to state 59

state 77

    (16) expression -> exp EQ . exp
    (11) exp -> . exp + termino
    (12) exp -> . exp - termino
    (13) exp -> . termino
    (33) termino -> . termino * factor
    (34) termino -> . termino / factor
    (35) termino -> . factor
    (21) factor -> . ( expression )
    (22) factor -> . ID
    (23) factor -> . cte
    (24) factor -> . + ID
    (25) factor -> . - ID
    (26) factor -> . + cte
    (27) factor -> . - cte
    (55) cte -> . CONST_INT
    (56) cte -> . CONST_FLOAT

    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    exp                            shift and go to state 108
    termino                        shift and go to state 55
    factor                         shift and go to state 57
    cte                            shift and go to state 59

state 78

    (17) expression -> exp GE . exp
    (11) exp -> . exp + termino
    (12) exp -> . exp - termino
    (13) exp -> . termino
    (33) termino -> . termino * factor
    (34) termino -> . termino / factor
    (35) termino -> . factor
    (21) factor -> . ( expression )
    (22) factor -> . ID
    (23) factor -> . cte
    (24) factor -> . + ID
    (25) factor -> . - ID
    (26) factor -> . + cte
    (27) factor -> . - cte
    (55) cte -> . CONST_INT
    (56) cte -> . CONST_FLOAT

    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    exp                            shift and go to state 109
    termino                        shift and go to state 55
    factor                         shift and go to state 57
    cte                            shift and go to state 59

state 79

    (18) expression -> exp LE . exp
    (11) exp -> . exp + termino
    (12) exp -> . exp - termino
    (13) exp -> . termino
    (33) termino -> . termino * factor
    (34) termino -> . termino / factor
    (35) termino -> . factor
    (21) factor -> . ( expression )
    (22) factor -> . ID
    (23) factor -> . cte
    (24) factor -> . + ID
    (25) factor -> . - ID
    (26) factor -> . + cte
    (27) factor -> . - cte
    (55) cte -> . CONST_INT
    (56) cte -> . CONST_FLOAT

    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    exp                            shift and go to state 110
    termino                        shift and go to state 55
    factor                         shift and go to state 57
    cte                            shift and go to state 59

state 80

    (19) expression -> exp NE . exp
    (11) exp -> . exp + termino
    (12) exp -> . exp - termino
    (13) exp -> . termino
    (33) termino -> . termino * factor
    (34) termino -> . termino / factor
    (35) termino -> . factor
    (21) factor -> . ( expression )
    (22) factor -> . ID
    (23) factor -> . cte
    (24) factor -> . + ID
    (25) factor -> . - ID
    (26) factor -> . + cte
    (27) factor -> . - cte
    (55) cte -> . CONST_INT
    (56) cte -> . CONST_FLOAT

    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    exp                            shift and go to state 111
    termino                        shift and go to state 55
    factor                         shift and go to state 57
    cte                            shift and go to state 59

state 81

    (11) exp -> exp + . termino
    (33) termino -> . termino * factor
    (34) termino -> . termino / factor
    (35) termino -> . factor
    (21) factor -> . ( expression )
    (22) factor -> . ID
    (23) factor -> . cte
    (24) factor -> . + ID
    (25) factor -> . - ID
    (26) factor -> . + cte
    (27) factor -> . - cte
    (55) cte -> . CONST_INT
    (56) cte -> . CONST_FLOAT

    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    termino                        shift and go to state 112
    factor                         shift and go to state 57
    cte                            shift and go to state 59

state 82

    (12) exp -> exp - . termino
    (33) termino -> . termino * factor
    (34) termino -> . termino / factor
    (35) termino -> . factor
    (21) factor -> . ( expression )
    (22) factor -> . ID
    (23) factor -> . cte
    (24) factor -> . + ID
    (25) factor -> . - ID
    (26) factor -> . + cte
    (27) factor -> . - cte
    (55) cte -> . CONST_INT
    (56) cte -> . CONST_FLOAT

    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    termino                        shift and go to state 113
    factor                         shift and go to state 57
    cte                            shift and go to state 59

state 83

    (24) factor -> + ID .

    *               reduce using rule 24 (factor -> + ID .)
    /               reduce using rule 24 (factor -> + ID .)
    >               reduce using rule 24 (factor -> + ID .)
    <               reduce using rule 24 (factor -> + ID .)
    EQ              reduce using rule 24 (factor -> + ID .)
    GE              reduce using rule 24 (factor -> + ID .)
    LE              reduce using rule 24 (factor -> + ID .)
    NE              reduce using rule 24 (factor -> + ID .)
    +               reduce using rule 24 (factor -> + ID .)
    -               reduce using rule 24 (factor -> + ID .)
    ;               reduce using rule 24 (factor -> + ID .)
    ,               reduce using rule 24 (factor -> + ID .)
    )               reduce using rule 24 (factor -> + ID .)


state 84

    (26) factor -> + cte .

    *               reduce using rule 26 (factor -> + cte .)
    /               reduce using rule 26 (factor -> + cte .)
    >               reduce using rule 26 (factor -> + cte .)
    <               reduce using rule 26 (factor -> + cte .)
    EQ              reduce using rule 26 (factor -> + cte .)
    GE              reduce using rule 26 (factor -> + cte .)
    LE              reduce using rule 26 (factor -> + cte .)
    NE              reduce using rule 26 (factor -> + cte .)
    +               reduce using rule 26 (factor -> + cte .)
    -               reduce using rule 26 (factor -> + cte .)
    ;               reduce using rule 26 (factor -> + cte .)
    ,               reduce using rule 26 (factor -> + cte .)
    )               reduce using rule 26 (factor -> + cte .)


state 85

    (33) termino -> termino * . factor
    (21) factor -> . ( expression )
    (22) factor -> . ID
    (23) factor -> . cte
    (24) factor -> . + ID
    (25) factor -> . - ID
    (26) factor -> . + cte
    (27) factor -> . - cte
    (55) cte -> . CONST_INT
    (56) cte -> . CONST_FLOAT

    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    factor                         shift and go to state 114
    cte                            shift and go to state 59

state 86

    (34) termino -> termino / . factor
    (21) factor -> . ( expression )
    (22) factor -> . ID
    (23) factor -> . cte
    (24) factor -> . + ID
    (25) factor -> . - ID
    (26) factor -> . + cte
    (27) factor -> . - cte
    (55) cte -> . CONST_INT
    (56) cte -> . CONST_FLOAT

    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    factor                         shift and go to state 115
    cte                            shift and go to state 59

state 87

    (25) factor -> - ID .

    *               reduce using rule 25 (factor -> - ID .)
    /               reduce using rule 25 (factor -> - ID .)
    >               reduce using rule 25 (factor -> - ID .)
    <               reduce using rule 25 (factor -> - ID .)
    EQ              reduce using rule 25 (factor -> - ID .)
    GE              reduce using rule 25 (factor -> - ID .)
    LE              reduce using rule 25 (factor -> - ID .)
    NE              reduce using rule 25 (factor -> - ID .)
    +               reduce using rule 25 (factor -> - ID .)
    -               reduce using rule 25 (factor -> - ID .)
    ;               reduce using rule 25 (factor -> - ID .)
    ,               reduce using rule 25 (factor -> - ID .)
    )               reduce using rule 25 (factor -> - ID .)


state 88

    (27) factor -> - cte .

    *               reduce using rule 27 (factor -> - cte .)
    /               reduce using rule 27 (factor -> - cte .)
    >               reduce using rule 27 (factor -> - cte .)
    <               reduce using rule 27 (factor -> - cte .)
    EQ              reduce using rule 27 (factor -> - cte .)
    GE              reduce using rule 27 (factor -> - cte .)
    LE              reduce using rule 27 (factor -> - cte .)
    NE              reduce using rule 27 (factor -> - cte .)
    +               reduce using rule 27 (factor -> - cte .)
    -               reduce using rule 27 (factor -> - cte .)
    ;               reduce using rule 27 (factor -> - cte .)
    ,               reduce using rule 27 (factor -> - cte .)
    )               reduce using rule 27 (factor -> - cte .)


state 89

    (21) factor -> ( expression . )

    )               shift and go to state 116


state 90

    (43) f_call -> ID ( expression f_call_ayuda . ) ;

    )               shift and go to state 117


state 91

    (45) f_call_ayuda -> , . expression f_call_ayuda
    (14) expression -> . exp > exp
    (15) expression -> . exp < exp
    (16) expression -> . exp EQ exp
    (17) expression -> . exp GE exp
    (18) expression -> . exp LE exp
    (19) expression -> . exp NE exp
    (20) expression -> . exp
    (11) exp -> . exp + termino
    (12) exp -> . exp - termino
    (13) exp -> . termino
    (33) termino -> . termino * factor
    (34) termino -> . termino / factor
    (35) termino -> . factor
    (21) factor -> . ( expression )
    (22) factor -> . ID
    (23) factor -> . cte
    (24) factor -> . + ID
    (25) factor -> . - ID
    (26) factor -> . + cte
    (27) factor -> . - cte
    (55) cte -> . CONST_INT
    (56) cte -> . CONST_FLOAT

    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    expression                     shift and go to state 118
    exp                            shift and go to state 53
    termino                        shift and go to state 55
    factor                         shift and go to state 57
    cte                            shift and go to state 59

state 92

    (46) f_call_ayuda -> empty .

    )               reduce using rule 46 (f_call_ayuda -> empty .)


state 93

    (44) f_call -> ID ( ) ; .

    }               reduce using rule 44 (f_call -> ID ( ) ; .)
    ID              reduce using rule 44 (f_call -> ID ( ) ; .)
    IF              reduce using rule 44 (f_call -> ID ( ) ; .)
    DO              reduce using rule 44 (f_call -> ID ( ) ; .)
    PRINT           reduce using rule 44 (f_call -> ID ( ) ; .)


state 94

    (37) condition -> IF ( expression marca . ) body ;

    )               shift and go to state 119


state 95

    (39) condition -> IF ( expression ) . save_gotof body save_goto_else ELSE body ;
    (40) save_gotof -> .

    {               reduce using rule 40 (save_gotof -> .)

    save_gotof                     shift and go to state 120

state 96

    (36) cycle -> DO body WHILE ( . expression ) ;
    (14) expression -> . exp > exp
    (15) expression -> . exp < exp
    (16) expression -> . exp EQ exp
    (17) expression -> . exp GE exp
    (18) expression -> . exp LE exp
    (19) expression -> . exp NE exp
    (20) expression -> . exp
    (11) exp -> . exp + termino
    (12) exp -> . exp - termino
    (13) exp -> . termino
    (33) termino -> . termino * factor
    (34) termino -> . termino / factor
    (35) termino -> . factor
    (21) factor -> . ( expression )
    (22) factor -> . ID
    (23) factor -> . cte
    (24) factor -> . + ID
    (25) factor -> . - ID
    (26) factor -> . + cte
    (27) factor -> . - cte
    (55) cte -> . CONST_INT
    (56) cte -> . CONST_FLOAT

    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    expression                     shift and go to state 121
    exp                            shift and go to state 53
    termino                        shift and go to state 55
    factor                         shift and go to state 57
    cte                            shift and go to state 59

state 97

    (28) print -> PRINT ( expression print_ayuda . ) ;

    )               shift and go to state 122


state 98

    (30) print_ayuda -> , . expression print_ayuda
    (31) print_ayuda -> , . STRING print_ayuda
    (14) expression -> . exp > exp
    (15) expression -> . exp < exp
    (16) expression -> . exp EQ exp
    (17) expression -> . exp GE exp
    (18) expression -> . exp LE exp
    (19) expression -> . exp NE exp
    (20) expression -> . exp
    (11) exp -> . exp + termino
    (12) exp -> . exp - termino
    (13) exp -> . termino
    (33) termino -> . termino * factor
    (34) termino -> . termino / factor
    (35) termino -> . factor
    (21) factor -> . ( expression )
    (22) factor -> . ID
    (23) factor -> . cte
    (24) factor -> . + ID
    (25) factor -> . - ID
    (26) factor -> . + cte
    (27) factor -> . - cte
    (55) cte -> . CONST_INT
    (56) cte -> . CONST_FLOAT

    STRING          shift and go to state 124
    (               shift and go to state 58
    ID              shift and go to state 51
    +               shift and go to state 54
    -               shift and go to state 56
    CONST_INT       shift and go to state 60
    CONST_FLOAT     shift and go to state 61

    expression                     shift and go to state 123
    exp                            shift and go to state 53
    termino                        shift and go to state 55
    factor                         shift and go to state 57
    cte                            shift and go to state 59

state 99

    (32) print_ayuda -> empty .

    )               reduce using rule 32 (print_ayuda -> empty .)


state 100

    (29) print -> PRINT ( CONST_STRING print_ayuda . ) ;

    )               shift and go to state 125


state 101

    (57) funcs -> VOID ID ( ID : type funcs_ayuda . ) [ vars body ] ;
    (59) funcs -> VOID ID ( ID : type funcs_ayuda . ) [ body ] ;

    )               shift and go to state 126


state 102

    (63) funcs_ayuda -> , . ID : type funcs_ayuda

    ID              shift and go to state 127


state 103

    (64) funcs_ayuda -> empty .

    )               reduce using rule 64 (funcs_ayuda -> empty .)


state 104

    (58) funcs -> VOID ID ( ) [ vars body . ] ;

    ]               shift and go to state 128


state 105

    (60) funcs -> VOID ID ( ) [ body ] . ;

    ;               shift and go to state 129


state 106

    (14) expression -> exp > exp .
    (11) exp -> exp . + termino
    (12) exp -> exp . - termino

    ;               reduce using rule 14 (expression -> exp > exp .)
    ,               reduce using rule 14 (expression -> exp > exp .)
    )               reduce using rule 14 (expression -> exp > exp .)
    +               shift and go to state 81
    -               shift and go to state 82


state 107

    (15) expression -> exp < exp .
    (11) exp -> exp . + termino
    (12) exp -> exp . - termino

    ;               reduce using rule 15 (expression -> exp < exp .)
    ,               reduce using rule 15 (expression -> exp < exp .)
    )               reduce using rule 15 (expression -> exp < exp .)
    +               shift and go to state 81
    -               shift and go to state 82


state 108

    (16) expression -> exp EQ exp .
    (11) exp -> exp . + termino
    (12) exp -> exp . - termino

    ;               reduce using rule 16 (expression -> exp EQ exp .)
    ,               reduce using rule 16 (expression -> exp EQ exp .)
    )               reduce using rule 16 (expression -> exp EQ exp .)
    +               shift and go to state 81
    -               shift and go to state 82


state 109

    (17) expression -> exp GE exp .
    (11) exp -> exp . + termino
    (12) exp -> exp . - termino

    ;               reduce using rule 17 (expression -> exp GE exp .)
    ,               reduce using rule 17 (expression -> exp GE exp .)
    )               reduce using rule 17 (expression -> exp GE exp .)
    +               shift and go to state 81
    -               shift and go to state 82


state 110

    (18) expression -> exp LE exp .
    (11) exp -> exp . + termino
    (12) exp -> exp . - termino

    ;               reduce using rule 18 (expression -> exp LE exp .)
    ,               reduce using rule 18 (expression -> exp LE exp .)
    )               reduce using rule 18 (expression -> exp LE exp .)
    +               shift and go to state 81
    -               shift and go to state 82


state 111

    (19) expression -> exp NE exp .
    (11) exp -> exp . + termino
    (12) exp -> exp . - termino

    ;               reduce using rule 19 (expression -> exp NE exp .)
    ,               reduce using rule 19 (expression -> exp NE exp .)
    )               reduce using rule 19 (expression -> exp NE exp .)
    +               shift and go to state 81
    -               shift and go to state 82


state 112

    (11) exp -> exp + termino .
    (33) termino -> termino . * factor
    (34) termino -> termino . / factor

    >               reduce using rule 11 (exp -> exp + termino .)
    <               reduce using rule 11 (exp -> exp + termino .)
    EQ              reduce using rule 11 (exp -> exp + termino .)
    GE              reduce using rule 11 (exp -> exp + termino .)
    LE              reduce using rule 11 (exp -> exp + termino .)
    NE              reduce using rule 11 (exp -> exp + termino .)
    +               reduce using rule 11 (exp -> exp + termino .)
    -               reduce using rule 11 (exp -> exp + termino .)
    ;               reduce using rule 11 (exp -> exp + termino .)
    ,               reduce using rule 11 (exp -> exp + termino .)
    )               reduce using rule 11 (exp -> exp + termino .)
    *               shift and go to state 85
    /               shift and go to state 86


state 113

    (12) exp -> exp - termino .
    (33) termino -> termino . * factor
    (34) termino -> termino . / factor

    >               reduce using rule 12 (exp -> exp - termino .)
    <               reduce using rule 12 (exp -> exp - termino .)
    EQ              reduce using rule 12 (exp -> exp - termino .)
    GE              reduce using rule 12 (exp -> exp - termino .)
    LE              reduce using rule 12 (exp -> exp - termino .)
    NE              reduce using rule 12 (exp -> exp - termino .)
    +               reduce using rule 12 (exp -> exp - termino .)
    -               reduce using rule 12 (exp -> exp - termino .)
    ;               reduce using rule 12 (exp -> exp - termino .)
    ,               reduce using rule 12 (exp -> exp - termino .)
    )               reduce using rule 12 (exp -> exp - termino .)
    *               shift and go to state 85
    /               shift and go to state 86


state 114

    (33) termino -> termino * factor .

    *               reduce using rule 33 (termino -> termino * factor .)
    /               reduce using rule 33 (termino -> termino * factor .)
    >               reduce using rule 33 (termino -> termino * factor .)
    <               reduce using rule 33 (termino -> termino * factor .)
    EQ              reduce using rule 33 (termino -> termino * factor .)
    GE              reduce using rule 33 (termino -> termino * factor .)
    LE              reduce using rule 33 (termino -> termino * factor .)
    NE              reduce using rule 33 (termino -> termino * factor .)
    +               reduce using rule 33 (termino -> termino * factor .)
    -               reduce using rule 33 (termino -> termino * factor .)
    ;               reduce using rule 33 (termino -> termino * factor .)
    ,               reduce using rule 33 (termino -> termino * factor .)
    )               reduce using rule 33 (termino -> termino * factor .)


state 115

    (34) termino -> termino / factor .

    *               reduce using rule 34 (termino -> termino / factor .)
    /               reduce using rule 34 (termino -> termino / factor .)
    >               reduce using rule 34 (termino -> termino / factor .)
    <               reduce using rule 34 (termino -> termino / factor .)
    EQ              reduce using rule 34 (termino -> termino / factor .)
    GE              reduce using rule 34 (termino -> termino / factor .)
    LE              reduce using rule 34 (termino -> termino / factor .)
    NE              reduce using rule 34 (termino -> termino / factor .)
    +               reduce using rule 34 (termino -> termino / factor .)
    -               reduce using rule 34 (termino -> termino / factor .)
    ;               reduce using rule 34 (termino -> termino / factor .)
    ,               reduce using rule 34 (termino -> termino / factor .)
    )               reduce using rule 34 (termino -> termino / factor .)


state 116

    (21) factor -> ( expression ) .

    *               reduce using rule 21 (factor -> ( expression ) .)
    /               reduce using rule 21 (factor -> ( expression ) .)
    >               reduce using rule 21 (factor -> ( expression ) .)
    <               reduce using rule 21 (factor -> ( expression ) .)
    EQ              reduce using rule 21 (factor -> ( expression ) .)
    GE              reduce using rule 21 (factor -> ( expression ) .)
    LE              reduce using rule 21 (factor -> ( expression ) .)
    NE              reduce using rule 21 (factor -> ( expression ) .)
    +               reduce using rule 21 (factor -> ( expression ) .)
    -               reduce using rule 21 (factor -> ( expression ) .)
    ;               reduce using rule 21 (factor -> ( expression ) .)
    ,               reduce using rule 21 (factor -> ( expression ) .)
    )               reduce using rule 21 (factor -> ( expression ) .)


state 117

    (43) f_call -> ID ( expression f_call_ayuda ) . ;

    ;               shift and go to state 130


state 118

    (45) f_call_ayuda -> , expression . f_call_ayuda
    (45) f_call_ayuda -> . , expression f_call_ayuda
    (46) f_call_ayuda -> . empty
    (2) empty -> .

    ,               shift and go to state 91
    )               reduce using rule 2 (empty -> .)

    f_call_ayuda                   shift and go to state 131
    empty                          shift and go to state 92

state 119

    (37) condition -> IF ( expression marca ) . body ;
    (54) body -> . { statements }

    {               shift and go to state 19

    body                           shift and go to state 132

state 120

    (39) condition -> IF ( expression ) save_gotof . body save_goto_else ELSE body ;
    (54) body -> . { statements }

    {               shift and go to state 19

    body                           shift and go to state 133

state 121

    (36) cycle -> DO body WHILE ( expression . ) ;

    )               shift and go to state 134


state 122

    (28) print -> PRINT ( expression print_ayuda ) . ;

    ;               shift and go to state 135


state 123

    (30) print_ayuda -> , expression . print_ayuda
    (30) print_ayuda -> . , expression print_ayuda
    (31) print_ayuda -> . , STRING print_ayuda
    (32) print_ayuda -> . empty
    (2) empty -> .

    ,               shift and go to state 98
    )               reduce using rule 2 (empty -> .)

    print_ayuda                    shift and go to state 136
    empty                          shift and go to state 99

state 124

    (31) print_ayuda -> , STRING . print_ayuda
    (30) print_ayuda -> . , expression print_ayuda
    (31) print_ayuda -> . , STRING print_ayuda
    (32) print_ayuda -> . empty
    (2) empty -> .

    ,               shift and go to state 98
    )               reduce using rule 2 (empty -> .)

    print_ayuda                    shift and go to state 137
    empty                          shift and go to state 99

state 125

    (29) print -> PRINT ( CONST_STRING print_ayuda ) . ;

    ;               shift and go to state 138


state 126

    (57) funcs -> VOID ID ( ID : type funcs_ayuda ) . [ vars body ] ;
    (59) funcs -> VOID ID ( ID : type funcs_ayuda ) . [ body ] ;

    [               shift and go to state 139


state 127

    (63) funcs_ayuda -> , ID . : type funcs_ayuda

    :               shift and go to state 140


state 128

    (58) funcs -> VOID ID ( ) [ vars body ] . ;

    ;               shift and go to state 141


state 129

    (60) funcs -> VOID ID ( ) [ body ] ; .

    MAIN            reduce using rule 60 (funcs -> VOID ID ( ) [ body ] ; .)
    VOID            reduce using rule 60 (funcs -> VOID ID ( ) [ body ] ; .)


state 130

    (43) f_call -> ID ( expression f_call_ayuda ) ; .

    }               reduce using rule 43 (f_call -> ID ( expression f_call_ayuda ) ; .)
    ID              reduce using rule 43 (f_call -> ID ( expression f_call_ayuda ) ; .)
    IF              reduce using rule 43 (f_call -> ID ( expression f_call_ayuda ) ; .)
    DO              reduce using rule 43 (f_call -> ID ( expression f_call_ayuda ) ; .)
    PRINT           reduce using rule 43 (f_call -> ID ( expression f_call_ayuda ) ; .)


state 131

    (45) f_call_ayuda -> , expression f_call_ayuda .

    )               reduce using rule 45 (f_call_ayuda -> , expression f_call_ayuda .)


state 132

    (37) condition -> IF ( expression marca ) body . ;

    ;               shift and go to state 142


state 133

    (39) condition -> IF ( expression ) save_gotof body . save_goto_else ELSE body ;
    (41) save_goto_else -> .

    ELSE            reduce using rule 41 (save_goto_else -> .)

    save_goto_else                 shift and go to state 143

state 134

    (36) cycle -> DO body WHILE ( expression ) . ;

    ;               shift and go to state 144


state 135

    (28) print -> PRINT ( expression print_ayuda ) ; .

    }               reduce using rule 28 (print -> PRINT ( expression print_ayuda ) ; .)
    ID              reduce using rule 28 (print -> PRINT ( expression print_ayuda ) ; .)
    IF              reduce using rule 28 (print -> PRINT ( expression print_ayuda ) ; .)
    DO              reduce using rule 28 (print -> PRINT ( expression print_ayuda ) ; .)
    PRINT           reduce using rule 28 (print -> PRINT ( expression print_ayuda ) ; .)


state 136

    (30) print_ayuda -> , expression print_ayuda .

    )               reduce using rule 30 (print_ayuda -> , expression print_ayuda .)


state 137

    (31) print_ayuda -> , STRING print_ayuda .

    )               reduce using rule 31 (print_ayuda -> , STRING print_ayuda .)


state 138

    (29) print -> PRINT ( CONST_STRING print_ayuda ) ; .

    }               reduce using rule 29 (print -> PRINT ( CONST_STRING print_ayuda ) ; .)
    ID              reduce using rule 29 (print -> PRINT ( CONST_STRING print_ayuda ) ; .)
    IF              reduce using rule 29 (print -> PRINT ( CONST_STRING print_ayuda ) ; .)
    DO              reduce using rule 29 (print -> PRINT ( CONST_STRING print_ayuda ) ; .)
    PRINT           reduce using rule 29 (print -> PRINT ( CONST_STRING print_ayuda ) ; .)


state 139

    (57) funcs -> VOID ID ( ID : type funcs_ayuda ) [ . vars body ] ;
    (59) funcs -> VOID ID ( ID : type funcs_ayuda ) [ . body ] ;
    (5) vars -> . VAR var_ayuda
    (54) body -> . { statements }

    VAR             shift and go to state 6
    {               shift and go to state 19

    vars                           shift and go to state 145
    body                           shift and go to state 146

state 140

    (63) funcs_ayuda -> , ID : . type funcs_ayuda
    (3) type -> . INT
    (4) type -> . FLOAT

    INT             shift and go to state 38
    FLOAT           shift and go to state 39

    type                           shift and go to state 147

state 141

    (58) funcs -> VOID ID ( ) [ vars body ] ; .

    MAIN            reduce using rule 58 (funcs -> VOID ID ( ) [ vars body ] ; .)
    VOID            reduce using rule 58 (funcs -> VOID ID ( ) [ vars body ] ; .)


state 142

    (37) condition -> IF ( expression marca ) body ; .

    }               reduce using rule 37 (condition -> IF ( expression marca ) body ; .)
    ID              reduce using rule 37 (condition -> IF ( expression marca ) body ; .)
    IF              reduce using rule 37 (condition -> IF ( expression marca ) body ; .)
    DO              reduce using rule 37 (condition -> IF ( expression marca ) body ; .)
    PRINT           reduce using rule 37 (condition -> IF ( expression marca ) body ; .)


state 143

    (39) condition -> IF ( expression ) save_gotof body save_goto_else . ELSE body ;

    ELSE            shift and go to state 148


state 144

    (36) cycle -> DO body WHILE ( expression ) ; .

    }               reduce using rule 36 (cycle -> DO body WHILE ( expression ) ; .)
    ID              reduce using rule 36 (cycle -> DO body WHILE ( expression ) ; .)
    IF              reduce using rule 36 (cycle -> DO body WHILE ( expression ) ; .)
    DO              reduce using rule 36 (cycle -> DO body WHILE ( expression ) ; .)
    PRINT           reduce using rule 36 (cycle -> DO body WHILE ( expression ) ; .)


state 145

    (57) funcs -> VOID ID ( ID : type funcs_ayuda ) [ vars . body ] ;
    (54) body -> . { statements }

    {               shift and go to state 19

    body                           shift and go to state 149

state 146

    (59) funcs -> VOID ID ( ID : type funcs_ayuda ) [ body . ] ;

    ]               shift and go to state 150


state 147

    (63) funcs_ayuda -> , ID : type . funcs_ayuda
    (63) funcs_ayuda -> . , ID : type funcs_ayuda
    (64) funcs_ayuda -> . empty
    (2) empty -> .

    ,               shift and go to state 102
    )               reduce using rule 2 (empty -> .)

    funcs_ayuda                    shift and go to state 151
    empty                          shift and go to state 103

state 148

    (39) condition -> IF ( expression ) save_gotof body save_goto_else ELSE . body ;
    (54) body -> . { statements }

    {               shift and go to state 19

    body                           shift and go to state 152

state 149

    (57) funcs -> VOID ID ( ID : type funcs_ayuda ) [ vars body . ] ;

    ]               shift and go to state 153


state 150

    (59) funcs -> VOID ID ( ID : type funcs_ayuda ) [ body ] . ;

    ;               shift and go to state 154


state 151

    (63) funcs_ayuda -> , ID : type funcs_ayuda .

    )               reduce using rule 63 (funcs_ayuda -> , ID : type funcs_ayuda .)


state 152

    (39) condition -> IF ( expression ) save_gotof body save_goto_else ELSE body . ;

    ;               shift and go to state 155


state 153

    (57) funcs -> VOID ID ( ID : type funcs_ayuda ) [ vars body ] . ;

    ;               shift and go to state 156


state 154

    (59) funcs -> VOID ID ( ID : type funcs_ayuda ) [ body ] ; .

    MAIN            reduce using rule 59 (funcs -> VOID ID ( ID : type funcs_ayuda ) [ body ] ; .)
    VOID            reduce using rule 59 (funcs -> VOID ID ( ID : type funcs_ayuda ) [ body ] ; .)


state 155

    (39) condition -> IF ( expression ) save_gotof body save_goto_else ELSE body ; .

    }               reduce using rule 39 (condition -> IF ( expression ) save_gotof body save_goto_else ELSE body ; .)
    ID              reduce using rule 39 (condition -> IF ( expression ) save_gotof body save_goto_else ELSE body ; .)
    IF              reduce using rule 39 (condition -> IF ( expression ) save_gotof body save_goto_else ELSE body ; .)
    DO              reduce using rule 39 (condition -> IF ( expression ) save_gotof body save_goto_else ELSE body ; .)
    PRINT           reduce using rule 39 (condition -> IF ( expression ) save_gotof body save_goto_else ELSE body ; .)


state 156

    (57) funcs -> VOID ID ( ID : type funcs_ayuda ) [ vars body ] ; .

    MAIN            reduce using rule 57 (funcs -> VOID ID ( ID : type funcs_ayuda ) [ vars body ] ; .)
    VOID            reduce using rule 57 (funcs -> VOID ID ( ID : type funcs_ayuda ) [ vars body ] ; .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for VOID in state 5 resolved as shift
WARNING: shift/reduce conflict for VOID in state 7 resolved as shift
WARNING: shift/reduce conflict for MAIN in state 7 resolved as shift
WARNING: shift/reduce conflict for VOID in state 12 resolved as shift
WARNING: shift/reduce conflict for VOID in state 12 resolved as shift
WARNING: shift/reduce conflict for ) in state 64 resolved as shift
WARNING: reduce/reduce conflict in state 12 resolved using rule (empty -> <empty>)
WARNING: rejected rule (funcs -> funcs funcs) in state 12
WARNING: Rule (funcs -> funcs funcs) is never reduced
